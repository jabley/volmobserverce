/*
This file is part of Volantis Mobility Server. 

Volantis Mobility Server is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Volantis Mobility Server is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Volantis Mobility Server.  If not, see <http://www.gnu.org/licenses/>. 
*/
/* ----------------------------------------------------------------------------
 * (c) Volantis Systems Ltd 2007. 
 * ----------------------------------------------------------------------------
 */

package com.volantis.osgi.cm;

import com.volantis.osgi.cm.dispatcher.Dispatcher;
import com.volantis.osgi.cm.factory.FactoryAssociation;
import com.volantis.osgi.cm.service.ServiceAssociation;
import com.volantis.osgi.cm.store.ConfigurationStore;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleContext;
import org.osgi.framework.Filter;
import org.osgi.framework.InvalidSyntaxException;
import org.osgi.framework.ServiceFactory;
import org.osgi.framework.ServiceReference;
import org.osgi.framework.ServiceRegistration;
import org.osgi.service.cm.ConfigurationAdmin;
import org.osgi.service.cm.ManagedService;
import org.osgi.service.cm.ManagedServiceFactory;
import org.osgi.service.log.LogService;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Dictionary;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * Underlying implementation of {@link ConfigurationAdmin} service.
 *
 * <p>There are some very complex dynamics and threading issues that can arise
 * in the {@link ConfigurationAdmin} service. These are simplified by causing
 * almost all requests into the {@link ConfigurationAdmin} service, and related
 * objects, as well as framework events to be routed through here. All external
 * methods are synchronized on this class.</p>
 *
 * <h3>Factory Configuration</h3>
 *
 * <p>There are a number of issue in the OSGi specification with regard to
 * factory configurations.</p>
 *
 * <ul>
 *
 * <li>It does not explain exactly when a factory PID becomes bound to a
 * particular location. It appears as though it happens when a {@link
 * ManagedServiceFactory} with a matching PID is first registered but it is not
 * clear.</li>
 *
 * <li>It allows configuration for the same factory PID to be bound to different
 * locations which will make some of it unusable as only one bundle can actually
 * use it. However, it does not really cover this situation and explain what is
 * supposed to happen.</li>
 *
 * </ul>
 */
public class ConfigurationAdminManager
        implements ServiceFactory, ConfigurationManager {

    /**
     * Empty array of references.
     */
    private static final ServiceReference[] EMPTY_REFERENCES =
        new ServiceReference[0];

    /**
     * The bundle context.
     */
    private final BundleContext bundleContext;

    /**
     * The log service.
     */
    private final LogService log;

    /**
     * The dispatcher for asynchronous tasks.
     */
    private final Dispatcher dispatcher;

    /**
     * The persistent store.
     */
    private final ConfigurationStore store;

    /**
     * A map from PID to association.
     *
     * <p>The PID is either a factory PID provided for a factory, or a PID
     * provided for a service. PIDs generated by the factory are never stored in
     * here. It is a fatal error if an attempt is made to get configuration for
     * a factory and a service where the factory PID matches the PID
     * respectively.</p>
     */
    private final Map pid2Association;

    /**
     * A map from PID to configuration.
     *
     * <p>The PID is either the PID for a service configuration, or the
     * automatically generated PID for a factory configuration. It is NOT a
     * factory PID.</p>
     */
    private final Map pid2Configuration;

    /**
     * A Map from {@link ServiceReference} to association.
     *
     * <p>This is needed to detect when a service changes its pid.</p>
     */
    private final Map reference2Association;

    /**
     * Initialise.
     *
     * @param bundleContext The bundle context.
     * @param log           The log service.
     * @param dispatcher    The dispatcher for asynchronous tasks.
     * @param store         The persistent store.
     * @throws IOException If there was a problem loading persistent
     *                     configurations.
     */
    public ConfigurationAdminManager(
            BundleContext bundleContext,
            LogService log, Dispatcher dispatcher,
            ConfigurationStore store)
            throws IOException {

        this.bundleContext = bundleContext;
        this.dispatcher = dispatcher;
        this.store = store;
        this.log = log;

        pid2Association = new HashMap();
        pid2Configuration = new HashMap();
        reference2Association = new HashMap();

        // Load the persistent configurations.
        InternalConfiguration[] configurations = store.load();
        if (configurations != null) {

            for (int i = 0; i < configurations.length; i++) {
                InternalConfiguration configuration = configurations[i];

                addConfigurationFromStore(configuration);
            }
        }
    }

    /**
     * Add an {@link InternalConfiguration} that was loaded from the store.
     *
     * @param configuration The configuration to add.
     */
    private void addConfigurationFromStore(
            InternalConfiguration configuration) {

        String pid = configuration.getPid();
        String factoryPid = configuration.getFactoryPid();
        if (factoryPid == null) {

            // Create the assocation.
            ServiceAssociation association = new ServiceAssociation(
                    log, pid, configuration);

            // Store the association away, making sure that it does not clash
            // with another association.
            if (pid2Association.containsKey(pid)) {
                throw new IllegalStateException("PID '" + pid + "' clashes");
            }
            pid2Association.put(pid, association);
        } else {

            // Get the factory association.
            FactoryAssociation association = getFactoryAssociation(factoryPid);

            // Add a configuration object to the factory association.
            association.addConfiguration(configuration);
        }

        // Store the configuration away, making sure that it does not clash
        // with another configuration.
        if (pid2Configuration.containsKey(pid)) {
            throw new IllegalStateException("PID '" + pid + "' clashes");
        }
        pid2Configuration.put(pid, configuration);

        // Dispatch update events to any listeners. The specification does not
        // say whether loading the configuration should (or should not) cause
        // update events to be dispatched, all it says is that an event should
        // be dispatched when either of the update methods is called. However,
        // this is needed because the current version of the Equinox Declarative
        // Services relies on receiving events when the ConfigurationAdmin
        // service starts up.
        //
        // The array of ServiceReferences is empty because they will be invoked
        // automatically when the ServiceTracker is opened which occurs after
        // this has been created.
        //
        // todo investigate whether this is needed in future.
        if (factoryPid == null) {
            dispatcher.managedServiceConfigurationUpdated(
                EMPTY_REFERENCES, configuration.createSnapshot());

        } else {
            dispatcher.managedServiceFactoryConfigurationUpdated(
                factoryPid, EMPTY_REFERENCES, configuration.createSnapshot());
        }
    }

    // Javadoc inherited.
    public Object getService(
            Bundle bundle, ServiceRegistration serviceRegistration) {

        return new BundleConfigurationAdmin(this, bundle);
    }

    public void ungetService(
            Bundle bundle, ServiceRegistration serviceRegistration,
            Object object) {
    }

    /**
     * Get the {@link FactoryAssociation} for the specified pid.
     *
     * <p>If no association existing already then create one and store it in the
     * {@link #pid2Association} map.</p>
     *
     * @param factoryPid The factory pid.
     * @return The {@link FactoryAssociation}.
     */
    private FactoryAssociation getFactoryAssociation(String factoryPid) {

        FactoryAssociation factoryAssociation;
        Association association = (Association)
                pid2Association.get(factoryPid);
        if (association == null) {
            // No association has been registered by anyone so it is ok to
            // use, without permission.
            factoryAssociation = new FactoryAssociation(log, factoryPid);

            pid2Association.put(factoryPid, factoryAssociation);

        } else if (association instanceof FactoryAssociation) {

            // Factory association already exists but it may be bound
            // to a different location.
            factoryAssociation = (FactoryAssociation) association;

        } else {
            // A service association has been registered which is an
            // error.
            throw new IllegalStateException(
                    FrameworkConstants.SERVICE_FACTORYPID + " '" +
                            factoryPid + "' clashed with " +
                            FrameworkConstants.SERVICE_PID);
        }

        return factoryAssociation;
    }

    /**
     * Create a factory configuration.
     *
     * <p>This is used for both the normal and admin create factory
     * configuration methods.</p>
     *
     * @param bundle           The bundle that invoked the service method.
     * @param factoryPid       The pid of the factory service.
     * @param bundleLocation   The location to which the configuration is to be
     *                         bound, may be null.
     * @param usingAdminMethod True if this is called by the admin method.
     * @return The newly created configuration.
     * @throws IOException If there was a problem persisting the configuration.
     */
    private synchronized InternalConfiguration createFactoryConfigurationImpl(
            Bundle bundle, String factoryPid, String bundleLocation,
            boolean usingAdminMethod) throws IOException {

        // Make sure that the factory PID is valid.
        ValidationHelper.checkFactoryPID(factoryPid);

        String callingLocation = bundle.getLocation();

        // Check to see if the calling bundle has permission to create
        // configurations for other bundles.
        boolean hasConfigurationPermission =
                SecurityHelper.hasConfigurePermission(bundle);

        if (usingAdminMethod && !hasConfigurationPermission) {
            // The caller requires but does not have permission to modify the
            // configuration of other bundles so this must fail.
            throw new SecurityException(
                    "Bundle '" + callingLocation +
                            "' does not have permission to create " +
                            "configuration for other bundles");
        }

        // Create the configuration for the factory.
        InternalConfiguration configuration =
                store.createFactoryConfiguration(factoryPid, bundleLocation);

        // Get the instance PID and perform a sanity check to make sure that it
        // is valid.
        String pid = configuration.getPid();
        ValidationHelper.checkPID(pid);

        FactoryAssociation association = getFactoryAssociation(factoryPid);

        if (!usingAdminMethod) {
            // Check to see if the factory PID is bound to a specific
            // location that is not the current bundle.
            String boundLocation = association.getBundleLocation();
            if (boundLocation == null) {
                // Binds to first bundle that registers
                // ManagedServiceFactory with the same factory PID.
            } else if (!callingLocation.equals(boundLocation)
                    && !hasConfigurationPermission) {

                // The association has been bound to another location but
                // the caller does not have permission to modify the
                // configuration of other bundles so this must fail.
                throw new SecurityException(
                        "Bundle '" + callingLocation +
                                "' does not have permission to create " +
                                "configuration for " +
                                FrameworkConstants.SERVICE_FACTORYPID +
                                " '" + factoryPid +
                                "' which is bound to bundle '" +
                                boundLocation + "'");
            } else {
                // A factory has already been registered with the pid that
                // matches this pid so bind it to the service immediately.
                configuration.bindToLocation(boundLocation);
            }
        }

        // Add the configuration to the set managed by the association.
        association.addConfiguration(configuration);

        // Create a mapping from pid to configuration.
        pid2Configuration.put(pid, configuration);

        return configuration;
    }

    // Javadoc inherited.
    public InternalConfiguration createFactoryConfiguration(
            Bundle bundle, String factoryPid)
            throws IOException {

        // This method is not synchronized so cannot access any fields of this
        // object.
        return createFactoryConfigurationImpl(bundle, factoryPid,
                bundle.getLocation(), false);
    }

    // Javadoc inherited.
    public InternalConfiguration createFactoryConfiguration(
            Bundle bundle, String factoryPid, String location)
            throws IOException {

        // This method is not synchronized so cannot access any fields of this
        // object.
        return createFactoryConfigurationImpl(bundle, factoryPid, location,
                true);
    }

    /**
     * Get the service association for the specified pid.
     *
     * <p>If no association existing already then create one and store it in the
     * {@link #pid2Association} map.</p>
     *
     * @param pid The pid.
     * @return The association.
     */
    private ServiceAssociation getServiceAssociation(String pid) {

        ServiceAssociation serviceAssociation;
        Association association = (Association) pid2Association.get(pid);
        if (association == null) {

            // No association has been registered by anyone so it is ok to
            // use, without permission.
            serviceAssociation = new ServiceAssociation(log, pid, null);

            pid2Association.put(pid, serviceAssociation);

        } else if (association instanceof ServiceAssociation) {

            // Service association already exists but it may be bound
            // to a different location.
            serviceAssociation = (ServiceAssociation) association;

        } else {
            // A factory association has been registered which is an
            // error.
            throw new IllegalStateException(
                    FrameworkConstants.SERVICE_PID + " '" +
                            pid + "' clashed with " +
                            FrameworkConstants.SERVICE_FACTORYPID);
        }

        return serviceAssociation;
    }

    /**
     * Get the configuration for the specified pid.
     *
     * @param bundle           The bundle that invoked the service method.
     * @param pid              The pid of the service.
     * @param bundleLocation   The location to which the configuration is to be
     *                         bound, may be null.
     * @param usingAdminMethod True if this is called by the admin method.
     * @return The newly created configuration.
     * @throws IOException If there was a problem persisting the configuration.
     */
    private synchronized InternalConfiguration getConfigurationImpl(
            Bundle bundle, String pid, String bundleLocation,
            boolean usingAdminMethod)
            throws IOException {

        // Make sure that the PID is valid.
        ValidationHelper.checkPID(pid);

        String callingLocation = bundle.getLocation();

        // Check to see if the calling bundle has permission to create
        // configurations for other bundles.
        boolean hasConfigurationPermission =
                SecurityHelper.hasConfigurePermission(bundle);

        if (usingAdminMethod && !hasConfigurationPermission) {
            // The caller is using the admin method (two argument) but does
            // not have permission to modify the configuration of other bundles
            // so this must fail.
            throw new SecurityException(
                    "Bundle '" + callingLocation +
                            "' does not have permission to create " +
                            "configuration for other bundles");
        }

        // Get the association for the PID. This may use an existing
        // association, or create a new one.
        ServiceAssociation association = getServiceAssociation(pid);

        // Make sure that the association has a configuration associated with
        // it.
        InternalConfiguration configuration;
        configuration = association.getConfiguration();
        if (configuration == null) {
            configuration = store.createConfiguration(pid, bundleLocation);
            association.setConfiguration(configuration);

            pid2Configuration.put(pid, configuration);
        }

        String boundLocation =
                configuration.getBundleLocation();
        if (boundLocation == null) {
            if (usingAdminMethod) {
                // The specification specifically states that the admin
                // method must not update the bundle location of an
                // already existing configuration (if this configuration
                // was newly created in this method then it would already
                // have been bound). The presumption is that the caller
                // will use the accessors on the configuration itself to
                // manage the bundle location.
            } else {
                // The non admin method must bind the configuration to
                // the location of the calling bundle.
                configuration.setSpecifiedLocation(bundleLocation);
            }

        } else if (!boundLocation.equals(callingLocation)) {

            if (!hasConfigurationPermission) {
                // The configuration has been bound to another location but
                // the caller does not have permission to modify the
                // configuration of other bundles so this must fail.
                throw new SecurityException(
                        "Bundle '" + callingLocation +
                                "' does not have permission to create " +
                                "configuration for " +
                                FrameworkConstants.SERVICE_PID +
                                " '" + pid +
                                "' which is bound to bundle '" +
                                boundLocation + "'");
            }
        }

        // If the association has already been bound to a specific location
        // then try and bind the configuration to the same location.
        String serviceLocation = association.getBundleLocation();
        if (serviceLocation != null) {
            configuration.bindToLocation(serviceLocation);
        }

        // Return the configuration.
        return configuration;
    }

    // Javadoc inherited.
    public InternalConfiguration getConfiguration(Bundle bundle, String pid)
            throws IOException {

        // This method is not synchronized so cannot access any fields of this
        // object.
        return getConfigurationImpl(bundle, pid, bundle.getLocation(), false);
    }

    // Javadoc inherited.
    public InternalConfiguration getConfiguration(
            Bundle bundle, String pid, String location) throws IOException {

        // This method is not synchronized so cannot access any fields of this
        // object.
        return getConfigurationImpl(bundle, pid, location, true);
    }

    // Javadoc inherited.
    public synchronized void deleteConfiguration(
            InternalConfiguration configuration)
            throws IOException {

        String pid;
        String factoryPid;

        // Make sure that the configuration has not been deleted.
        configuration.ensureNotDeleted();

        // Remove the configuration from the store. If this fails then this
        // method will return immediately and not update any state, or
        // trigger any events.
        store.remove(configuration);

        // Extract the information from the configuration that is necessary
        // to dispatch events and store the configuration.
        pid = configuration.getPid();
        factoryPid = configuration.getFactoryPid();

        if (factoryPid == null) {
            ServiceAssociation association = (ServiceAssociation)
                    pid2Association.get(pid);
            if (association == null) {
                // Shouldn't happen.
            } else {
                // Remove the configuration from the association.
                association.setConfiguration(null);

                if (association.hasConfiguration()
                        || association.hasTargets()) {

                    dispatcher.managedServiceConfigurationDeleted(pid,
                            association.getConfigurationTargets());
                } else {
                    // The association has no configuration and no targets so
                    // discard it to prevent it becoming a memory leak.
                    pid2Association.remove(pid);
                }
            }
        } else {
            FactoryAssociation association = (FactoryAssociation)
                    pid2Association.get(factoryPid);
            if (association == null) {
                // Shouldn't happen.
            } else {
                // Remove the configuration from the association.
                association.removeConfiguration(pid);

                if (association.hasConfiguration() ||
                        association.hasTargets()) {
                    dispatcher.managedServiceFactoryConfigurationDeleted(
                            factoryPid,
                            pid, association.getConfigurationTargets());
                } else {
                    // The association is not useful so discard it.
                    pid2Association.remove(factoryPid);
                }
            }
        }

        // Remove the configuration.
        pid2Configuration.remove(pid);

        // Mark the configuration as deleted. The idea behind separating the
        // deletion into two phases was to allow the internal code to keep
        // using the configuration for a little bit longer than the external
        // code in order to prevent race conditions but we don't need that at
        // the moment. However, the specification is not clear whether the
        // behaviour that we currently have can be viewed as having race
        // conditions so we are leaving them in for now.
        configuration.beginDeleting();
        configuration.deleteCompleted();
    }

    // Javadoc inherited.
    public synchronized void updateConfiguration(
            InternalConfiguration configuration, Dictionary properties)
            throws IOException {

        // Make sure that the configuration has not been deleted.
        configuration.ensureNotDeleted();

        if (properties != null) {
            // Update the properties for the configuration.
            configuration.replaceProperties(properties);
        }

        // Extract the information from the configuration that is necessary
        // to dispatch events and store the configuration.
        String pid = configuration.getPid();
        String factoryPid = configuration.getFactoryPid();

        // Update the configuration in the store. Is not really necessary
        // if the configuration has not changed because no properties
        // were provided.
        if (properties != null) {
            store.update(configuration);
        }

        // Invoke the callback, this is done while synchronized to ensure
        // that events for a specific configuration are produced in the
        // correct order.

        // Invoke any targets.
        if (factoryPid == null) {
            Association association = getServiceAssociation(pid);

            // Bind the configuration to this bundle. If the configuration is
            // already bound to a different location then ignore it.
            //
            // OSGi Specification States:
            //     If a Managed Service is registered with a PID that is already
            //     bound to another location, the normal callback to
            //     ManagedService.updated must not take place.
            //
            String bundleLocation = association.getBundleLocation();
            if (bundleLocation != null) {
                if (!configuration.bindToLocation(bundleLocation)) {
                    return;
                }
            }

            dispatcher.managedServiceConfigurationUpdated(
                    association.getConfigurationTargets(),
                    configuration.createSnapshot());

        } else {
            FactoryAssociation association = getFactoryAssociation(factoryPid);

            // Bind the configuration to this bundle. If the configuration is
            // already bound to a different location then ignore it.
            //
            // OSGi Specification States:
            //     If a Managed Service is registered with a PID that is already
            //     bound to another location, the normal callback to
            //     ManagedService.updated must not take place.
            //
            // Although the specification is talking about a ManagedService it
            // is assumed that the same applies to ManagedServiceFactory.
            String bundleLocation = association.getBundleLocation();
            if (bundleLocation != null) {
                if (!configuration.bindToLocation(bundleLocation)) {
                    return;
                }
            }

            dispatcher.managedServiceFactoryConfigurationUpdated(
                    factoryPid, association.getConfigurationTargets(),
                    configuration.createSnapshot());
        }
    }

    // Javadoc inherited.
    public synchronized void setConfigurationBundleLocation(
            InternalConfiguration configuration, String bundleLocation) {
        configuration.setSpecifiedLocation(bundleLocation);
    }

    // Javadoc inherited.
    public synchronized String getConfigurationBundleLocation(
            InternalConfiguration configuration) {
        return configuration.getBundleLocation();
    }

    /**
     * Bind the target service to the association.
     *
     * @param association The association to which the service will be bound.
     * @param reference   The service reference.
     * @return True if binding was successful false if it failed, probably due
     *         to some location binding conflict.
     */
    private boolean bindTargetToAssociation(
            Association association, ServiceReference reference) {

        // Try and see whether the association can be bound to the specified
        // location. If it can't then stop as it means that that it has already
        // been bound to a service in a different bundle.
        if (!association.bindToLocation(reference)) {
            return false;
        }

        reference2Association.put(reference, association);

        return true;
    }

    /**
     * Unbind the target service from the association.
     *
     * @param association The association from which the service will be
     *                    unbound.
     * @param reference   The service to unbind.
     */
    private void unbindTargetFromAssociation(
            Association association, ServiceReference reference) {

        reference2Association.remove(reference);

        // If the association is not bound to a location then check to see
        // whether it has any configuration because if it does not then it can
        // be removed.
        if (association.unbindFromLocation(reference)) {
            if (!association.hasConfiguration()) {
                pid2Association.remove(association.getServicePid());
            }
        }
    }

    // Javadoc inherited.
    public synchronized void factoryRegistered(ServiceReference reference) {

        // Get the factory pid for the service. This actually uses the same
        // property name as the PID.
        String factoryPid = getServicePID(reference);
        if (factoryPid == null) {
            log.log(reference, LogService.LOG_ERROR,
                    "No " + FrameworkConstants.SERVICE_PID +
                            " specified for the ManagedServiceFactory");
            return;
        }

        factoryRegisteredInternal(factoryPid, reference);
    }

    /**
     * A {@link ManagedServiceFactory} has just been registered.
     *
     * <p>Unsynchronized method that can be used by other methods.</p>
     *
     * @param factoryPid The service pid.
     * @param reference  The service reference.
     */
    private void factoryRegisteredInternal(
            String factoryPid, ServiceReference reference) {

        FactoryAssociation association = getFactoryAssociation(factoryPid);

        // Attempt to bind the target to the association if it cannot then
        // return immediately.
        if (!bindTargetToAssociation(association, reference)) {
            return;
        }

        ConfigurationSnapshot[] snapshots =
                association.createSnapshots(reference);

        dispatcher.managedServiceFactoryRegistered(
                factoryPid, reference, snapshots);
    }

    // Javadoc inherited.
    public void factoryModified(ServiceReference reference) {

        // Get the pid for the service.
        String newPid = getServicePID(reference);

        // The properties associated with the ManagedService have changed
        // so that could include the pid. Get the association that was used
        // for this reference.
        FactoryAssociation association =
                (FactoryAssociation) reference2Association.get(reference);
        if (association == null) {
            // When this service registered there was a problem attempting
            // to create an association so just return. It was probably
            // because it used a pid that it was already bound to some
            // other bundle. Just return silently as any warnings will
            // already have been logged.
            return;
        }

        String currentPid = association.getServicePid();

        // If the pid hasn't changed then this has no impact so the
        // service stays bound.
        if (currentPid.equals(newPid)) {
            return;
        }

        // Remove this reference as a target for the current
        // association.
        unbindTargetFromAssociation(association, reference);

        // Now behave as if this service has just registered.
        factoryRegisteredInternal(newPid, reference);
    }

    // Javadoc inherited.
    public void factoryUnregistering(ServiceReference reference) {

        // Get the association for this service.
        FactoryAssociation association = (FactoryAssociation)
                reference2Association.get(reference);
        if (association == null) {
            // When this service registered there was a problem attempting
            // to create an association so just return. It was probably because
            // it used a pid that it was already bound to some other bundle.
            // Just return silently as any warnings will already have been
            // logged.
            return;
        }

        // Remove this reference as a target for the association.
        unbindTargetFromAssociation(association, reference);
    }

    // Javadoc inherited.
    public synchronized void serviceRegistered(ServiceReference reference) {

        // Get the pid for the service.
        String pid = getServicePID(reference);
        if (pid == null) {
            log.log(reference, LogService.LOG_ERROR,
                    "No " + FrameworkConstants.SERVICE_PID +
                            " specified");
            return;
        }

        serviceRegisteredInternal(pid, reference);
    }

    /**
     * A {@link ManagedService} has just been registered.
     *
     * <p>Unsynchronized method that can be used by other methods.</p>
     *
     * @param pid       The service pid.
     * @param reference The service reference.
     */
    private void serviceRegisteredInternal(
            String pid, ServiceReference reference) {

        // Get an association for the service creating one if necessary.
        ServiceAssociation association = getServiceAssociation(pid);

        // Attempt to bind the target to the association if it cannot then
        // return immediately.
        if (!bindTargetToAssociation(association, reference)) {
            return;
        }

        // Get the configuration.
        ConfigurationSnapshot snapshot;
        InternalConfiguration configuration =
                association.getConfiguration();
        if (configuration == null) {
            // No configuration is available.
            snapshot = null;
        } else {
            snapshot = configuration.createSnapshot();
        }

        // Queue a task to perform the appropriate callbacks for the fact
        // that a ManagedService has registered.
        dispatcher.managedServiceRegistered(reference, snapshot);
    }

    // Javadoc inherited.
    public void serviceModified(ServiceReference reference) {

        // Get the pid for the service.
        String newPid = getServicePID(reference);

        // The properties associated with the ManagedService have changed
        // so that could include the pid. Get the association that was used
        // for this reference.
        ServiceAssociation association =
                (ServiceAssociation) reference2Association.get(reference);
        if (association == null) {
            // When this service registered there was a problem attempting
            // to create an association probably because it used a pid that
            // was already bound to some other bundle. The pid may have
            // changed so try again.
        } else {

            String currentPid = association.getServicePid();

            // If the pid hasn't changed then this has no impact.
            if (currentPid.equals(newPid)) {
                return;
            }

            // Remove this reference as a target for the current
            // association.
            unbindTargetFromAssociation(association, reference);
        }

        // Now behave as if this service has just registered.
        serviceRegisteredInternal(newPid, reference);
    }

    // Javadoc inherited.
    public synchronized void serviceUnregistering(ServiceReference reference) {

        // Get the association for this service.
        ServiceAssociation association = (ServiceAssociation)
                reference2Association.get(reference);
        if (association == null) {
            // When this service registered there was a problem attempting
            // to create an association so just return. It was probably
            // because it used a pid that was already bound to some other
            // bundle. Just return silently as any warnings will already
            // have been logged.
            return;
        }

        // Remove this reference as a target for the association.
        unbindTargetFromAssociation(association, reference);
    }

    /**
     * Get the service PID.
     *
     * <p>This can be used to retrieve the PID for a ManagedService, or the PID
     * for a ManagedServiceFactory, the latter of which is the factory PID.</p>
     *
     * @param reference The service reference.
     * @return The PID, may be null.
     */
    private String getServicePID(ServiceReference reference) {
        return (String) reference.getProperty(FrameworkConstants.SERVICE_PID);
    }

    // Javadoc inherited.
    public synchronized Dictionary getConfigurationProperties(
            InternalConfiguration configuration) {

        return configuration.getProperties();
    }

    // Javadoc inherited.
    public synchronized InternalConfiguration[] listConfigurations(
            Bundle bundle, String filter)
            throws IOException, InvalidSyntaxException {

        boolean hasConfigurePermission =
                SecurityHelper.hasConfigurePermission(bundle);

        Filter f;
        if (filter == null) {
            f = null;
        } else {
            f = bundleContext.createFilter(filter);
        }

        String callingLocation = bundle.getLocation();

        List matchedList = new ArrayList();
        for (Iterator i = pid2Configuration.values().iterator();
             i.hasNext();) {

            InternalConfiguration configuration =
                    (InternalConfiguration) i.next();

            // If the configuration doesn't have any properties set then
            // ignore it as per the specification.
            Dictionary properties = configuration.getProperties();
            if (properties == null) {
                continue;
            }

            // If the caller doesn't have configure permission then don't
            // let them see configurations not bound to their location.
            if (!hasConfigurePermission
                    && !callingLocation.equals(
                    configuration.getBundleLocation())) {
                continue;
            }

            boolean matched;
            if (f == null) {
                matched = true;
            } else {
                matched = f.match(properties);
            }


            if (matched) {
                matchedList.add(configuration);
            }
        }

        if (matchedList.isEmpty()) {
            return null;
        } else {
            InternalConfiguration[] configurations =
                    new InternalConfiguration[matchedList
                            .size()];
            matchedList.toArray(configurations);
            return configurations;
        }
    }
}
