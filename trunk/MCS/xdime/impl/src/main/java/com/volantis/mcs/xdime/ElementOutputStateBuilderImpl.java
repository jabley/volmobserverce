/*
This file is part of Volantis Mobility Server. 

Volantis Mobility Server is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Volantis Mobility Server is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Volantis Mobility Server.  If not, see <http://www.gnu.org/licenses/>. 
*/
/* ----------------------------------------------------------------------------
 * (c) Volantis Systems Ltd 2006. 
 * ----------------------------------------------------------------------------
 */
package com.volantis.mcs.xdime;

import com.volantis.mcs.context.ContextInternals;
import com.volantis.mcs.context.MarinerPageContext;
import com.volantis.mcs.layouts.Format;
import com.volantis.mcs.layouts.FormatNamespace;
import com.volantis.mcs.layouts.NDimensionalIndex;
import com.volantis.mcs.localization.LocalizationFactory;
import com.volantis.mcs.protocols.DeviceLayoutContext;
import com.volantis.mcs.protocols.FormatReference;
import com.volantis.mcs.protocols.layouts.ContainerInstance;
import com.volantis.mcs.protocols.layouts.RegionInstance;
import com.volantis.mcs.repository.RepositoryException;
import com.volantis.mcs.runtime.layouts.RuntimeDeviceLayout;
import com.volantis.mcs.runtime.layouts.StyleFormatReference;
import com.volantis.mcs.themes.StyleKeyword;
import com.volantis.mcs.themes.StylePropertyDetails;
import com.volantis.mcs.themes.StyleString;
import com.volantis.mcs.themes.StyleValue;
import com.volantis.mcs.themes.properties.DisplayKeywords;
import com.volantis.mcs.themes.properties.MCSContainerKeywords;
import com.volantis.mcs.themes.properties.MCSLayoutKeywords;
import com.volantis.styling.Styles;
import com.volantis.styling.values.MutablePropertyValues;
import com.volantis.synergetics.localization.ExceptionLocalizer;
import com.volantis.synergetics.log.LogDispatcher;

/**
 * Concrete implementation of the {@link ElementOutputStateBuilder} interface.
 */
public class ElementOutputStateBuilderImpl
        implements ElementOutputStateBuilder {

    /**
     * Used to retrieve localized exception messages.
     */
    private static final ExceptionLocalizer EXCEPTION_LOCALIZER =
            LocalizationFactory.createExceptionLocalizer(
                    ElementOutputStateBuilderImpl.class);

    /**
     * Used for logging.
     */
    private static final LogDispatcher LOGGER =
            LocalizationFactory.createLogger(
                    ElementOutputStateBuilderImpl.class);

    /**
     * Context in which this builder is being used.
     */
    private final XDIMEContextInternal context;

    /**
     * The parent output state, may be null.
     */
    private final ElementOutputState parentState;

    /**
     * Unique identifier (in the document) of the element that is currently
     * being processed (whose output state the built object will describe).
     */
    private final String elementID;

    /**
     * Styles which will be used to calculate if and where any output markup
     * generated by the element that is currently being processed should
     * appear. May be null if the element is unstyled, in which case the
     * default values will be used.
     */
    private final Styles styles;

    /**
     * Indicates if element is atomic.
     * Element is atomic, if its children cannot exist without this element. Thus if this
     * element is removed, its children should be removed as well.
     */
    private final boolean isElementAtomic;

    /**
     * Indicates whether or not the element to which this output state
     * applies either is, or is contained by, an inactive group.
     */
    protected boolean isInactiveGroup;

    /**
     * Indicates whether or not the styles explicitly specified the
     * current container (not by name).
     */
    protected boolean specifiedCurrentContainer;

    /**
     * A flag indicating, that elements with display:none styles should not be
     * skipped.
     */
    private final boolean suppressSkipForDisplayNone;
    
    public ElementOutputStateBuilderImpl(
            XDIMEContextInternal context, ElementOutputState parentState,
            String elementID, Styles styles) {

        this(context, parentState, elementID, styles, false, false);
    }

    public ElementOutputStateBuilderImpl(
            XDIMEContextInternal context, ElementOutputState parentState,
            String elementID, Styles styles, boolean isElementAtomic) {

        this(context, parentState, elementID, styles, false, isElementAtomic);
    }
    
    public ElementOutputStateBuilderImpl(
            XDIMEContextInternal context, ElementOutputState parentState,
            String elementID, Styles styles,
            boolean suppressSkipForDisplayNone,
            boolean isElementAtomic) {

        if (context == null) {
            throw new IllegalArgumentException("context cannot be null");
        }

        this.context = context;
        this.parentState = parentState;
        this.elementID = elementID;
        this.styles = styles;
        this.suppressSkipForDisplayNone = suppressSkipForDisplayNone;
        this.isElementAtomic = isElementAtomic;
    }

    // Javadoc inherited.
    public void setInactiveGroup(boolean inactiveGroup) {
        isInactiveGroup = inactiveGroup;
    }

    // Javadoc inherited.
    public ElementOutputState createElementOutputState() {

        ElementOutputState state;
        if (context == null) {
            throw new IllegalStateException("Cannot create an " +
                    "ElementOutputState with no context");
        } else {

            StyleValue layoutRef = null;
            StyleValue containerRef = null;
            StyleValue display = null;

            // Determine the formatting styles that were specified.
            if (styles != null) {
                MutablePropertyValues propertyValues = styles.getPropertyValues();
                layoutRef = propertyValues.getComputedValue(
                        StylePropertyDetails.MCS_LAYOUT);

                containerRef = propertyValues.getComputedValue(
                        StylePropertyDetails.MCS_CONTAINER);

                display = propertyValues.getComputedValue(
                        StylePropertyDetails.DISPLAY);
            } else {
                LOGGER.debug("No styles were specified for this element, so the " +
                        "output will appear in the current container if it is " +
                        "valid");
            }

            if (display == DisplayKeywords.NONE && !suppressSkipForDisplayNone) {
                // If the display is set to none then skip the element.
                state = new ElementOutputStateImpl(context, FormattingResult.SKIP,
                        isInactiveGroup, elementID);
            } else {

                // Use default values if no styles were specified.
                if (layoutRef == null) {
                    layoutRef = MCSLayoutKeywords.CURRENT;
                }

                if (containerRef == null) {
                    containerRef = MCSContainerKeywords.CURRENT;
                }

                // Evaluate the styles to determine the layout and containers that
                // were specified, and create the element output state.
                state = createElementOutputState(layoutRef, containerRef);
            }

        }
        return state;
    }

    /**
     * Evaluates the specified container and layout in order to determine the
     * current element output state.
     *
     * @param layout            the style value describing the layout which
     *                          should be used
     * @param container         the style value describing the container which
     *                          should be used
     * @return ElementOutputState which describes if and where the element to
     * which this state applies should generate or suppress markup (and if
     * generating, where the markup should appear)
     */
    private ElementOutputState createElementOutputState(StyleValue layout,
                                                        StyleValue container) {

        MarinerPageContext pageContext =
                ContextInternals.getMarinerPageContext(
                        context.getInitialRequestContext());

        // Get the specified container - may be null.
        DeviceLayoutContext layoutContext =
                getSpecifiedLayout(layout, pageContext);

        // If a layout was specified, then ensure it is allowed in this context.
        RegionInstance containingRegion = null;
        if (layoutContext != null) {
            ContainerInstance containingInstance =
                        pageContext.getCurrentContainerInstance();

            // Make sure that the containing instance is a region.
            if (containingInstance instanceof RegionInstance) {
                containingRegion = (RegionInstance) containingInstance;
            } else {
                throw new IllegalStateException("Container " +
                        containingInstance.getFormat().getName() +
                        " is not a region");
            }
        }

        // If the parent of the element currently being processed is in an
        // inactive group, then the current element must also be.
        boolean suppressedLayout = false;
        if (parentState != null) {
            if (parentState.isInactiveGroup()) {
                isInactiveGroup = true;
            }
            if (parentState.isSuppressing() && layoutContext != null ||
                    parentState.isInSuppressedLayout()) {
                // if you push a new layout on while the parent is suppressing,
                // all the elements should remain suppressed even if they
                // target valid containers. This is because the layout itself
                // wasn't correctly targetted at a valid container.
                suppressedLayout = true;
            }
        }

        // Get the specified container - may be null.
        ContainerInstance containerInstance =
                getSpecifiedContainer(container, pageContext, layoutContext);

        // Determine the formatting result given the layout and container.
        FormattingResult formattingResult =
                determineFormattingResult(layoutContext, containerInstance,
                        suppressedLayout);

        // Determine if specified element along with all its descendants should
        // be suppressed.
        boolean suppressDescendants =
                (parentState != null && parentState.isSuppressingDescendants())
                || (formattingResult == FormattingResult.SUPPRESS && isElementAtomic);

        // Create the element output state which encapsulates this information.
        ElementOutputState state = new ElementOutputStateImpl(
                containerInstance, layoutContext, containingRegion,
                formattingResult, isInactiveGroup, elementID, context,
                getSpecifiedContainerName(container),
                suppressedLayout, suppressDescendants);

        return state;
    }

    /**
     * Evaluate the mcs-layout style and return the specified layout context.
     * This may be null if no layout was specified.
     *
     * @param layout            the style value describing the layout which
     *                          should be used
     * @param pageContext       in which this layout is being referenced.
     * @return DeviceLayoutContext that was referenced. May be null if none
     * was specified.
     */
    private DeviceLayoutContext getSpecifiedLayout(
            StyleValue layout, MarinerPageContext pageContext) {

        DeviceLayoutContext layoutContext = null;

        // Process an mcs-layout style first.
        if (layout instanceof StyleString) {
            StyleString layoutString = (StyleString) layout;

            String layoutName = layoutString.getString();

            // only create new layout context if the specified layout is not
            // the current one
            if (!pageContext.getDeviceLayout().getName().equals(layoutName)) {
                // Push the newly specified layout onto the stack in the
                // page context.
                try {
                    layoutContext =
                        createDeviceLayoutContext(pageContext, layoutName);
                } catch (XDIMEException e) {
                    LOGGER.warn(e);
                    throw new IllegalStateException(
                        "Could not create DeviceLayoutContext for " + layout);
                }
            }
        } else if (layout instanceof StyleKeyword) {
            if (layout == MCSLayoutKeywords.CURRENT) {
                // Nothing to do.
            } else {
                throw new IllegalStateException(
                        "Unknown keyword for mcs-layout: " + layout);
            }
        } else {
            throw new IllegalStateException(
                    "Unknown style value for mcs-layout: " + layout);
        }

        return layoutContext;
    }

    /**
     * Evaluate the mcs-container style and return the specified container
     * instance. This may be null if no container was explicitly specified.
     *
     * @param container         style value which specifies the requested container
     * @param pageContext       in which this container is being referenced
     * @param specifiedLayout   layout which was specified by the styles.
     *                          May be null
     * @return ContainerInstance that was referenced. May be null if none
     * was specified.
     */
    protected ContainerInstance getSpecifiedContainer(
            StyleValue container,
            MarinerPageContext pageContext,
            DeviceLayoutContext specifiedLayout) {

        ContainerInstance instance = null;
        String containerName = getSpecifiedContainerName(container);

        if (container instanceof StyleFormatReference) {
            StyleFormatReference styleFormatReference =
                    (StyleFormatReference) container;
            FormatReference reference = styleFormatReference.getReference();

            // Try and find the format instance.
            Format format = pageContext.getFormat(reference.getStem(),
                    FormatNamespace.CONTAINER);
            if (format != null) {
                instance = (ContainerInstance) pageContext.getFormatInstance(
                        format, reference.getIndex());
            }

        } else if (containerName != null) {

            final ContainerInstance currentContainer =
                pageContext.getCurrentContainerInstance();
            if (specifiedLayout == null && currentContainer != null &&
                containerName.equals(currentContainer.getFormat().getName())) {
                // if no new layout is specified and the container name is the
                // same as the name of the current container then we can use the
                // current container
                specifiedCurrentContainer = true;
            } else {
                DeviceLayoutContext layoutContext = specifiedLayout;
                if (layoutContext == null) {
                    // If none was specified, then try and find the format in
                    // the current layout.
                    layoutContext = pageContext.getDeviceLayoutContext();
                }
                Format format = layoutContext.getFormat(containerName,
                        FormatNamespace.CONTAINER);

                if (format != null) {
                    int dimensions = format.getDimensions();
                    NDimensionalIndex index;
                    if (dimensions > 0) {
                        int[] indeces = new int[dimensions];
                        index = new NDimensionalIndex(indeces);
                    } else {
                        index = NDimensionalIndex.ZERO_DIMENSIONS;
                    }

                    instance = (ContainerInstance) layoutContext.
                            getFormatInstance(format, index);
                }
            }
        } else if (container instanceof StyleKeyword) {
            if (container == MCSContainerKeywords.CURRENT) {
                // Instance is the current one.
                specifiedCurrentContainer = true;
            } else {
                throw new IllegalStateException("Unknown keyword value for " +
                        "mcs-container: " + container);
            }
        } else {
            throw new IllegalStateException(
                    "Unknown style value for mcs-container: " + container);
        }

        return instance;
    }

    /**
     * Evaluate the updated container and layout references and determine
     * whether the formatting result should be
     * ({@link FormattingResult#PROCESS), {@link FormattingResult#SKIP) or
     * {@link FormattingResult#SUPPRESS)).
     *
     * @param layoutContext         the specified layout, may be null
     * @param containerInstance     the specified container, may be null
     * @return FormattingResult the formatting result
     */
    protected FormattingResult determineFormattingResult(
            DeviceLayoutContext layoutContext,
            ContainerInstance containerInstance, boolean suppressedLayout) {

        FormattingResult formattingResult;
        if (specifiedCurrentContainer) {
            // The current instance was requested (not by name) so we should
            // suppress if we were currently suppressing, and process otherwise.
            if (layoutContext != null || (parentState != null &&
                    parentState.isSuppressing())) {
                formattingResult = FormattingResult.SUPPRESS;
            } else {
                formattingResult = FormattingResult.PROCESS;
            }
        } else if (containerInstance == null || containerInstance.ignore()) {
            formattingResult = isElementAtomic
                    ? FormattingResult.SUPPRESS
                    : FormattingResult.SKIP;
        } else {
            if (isInactiveGroup || suppressedLayout ||
                    parentState != null &&
                    parentState.isInSuppressedLayout()) {
                // Even if the layout and container are correctly specified so
                // the element should not be suppressed, the state of any
                // containing group overrides this.
                formattingResult = FormattingResult.SUPPRESS;
            } else {
                formattingResult = FormattingResult.PROCESS;
            }
        }
        return formattingResult;
    }

    /**
     * Create and initialise the {@link DeviceLayoutContext} which is specified
     * by the given layout name.
     *
     * @param pageContext   in which this layout context is being created
     * @param layoutName    name of the layout which will be retrieved from
     *                      the page context
     * @return DeviceLayoutContext which is specified by the layout name
     * @throws XDIMEException - if there was a problem finding the layout
     */
    private DeviceLayoutContext createDeviceLayoutContext(
            MarinerPageContext pageContext, String layoutName)
            throws XDIMEException {
        RuntimeDeviceLayout deviceLayout;
        try {
            deviceLayout = pageContext.getDeviceLayout(layoutName);

            // If a layout could not be found then fail immediately.
            if (deviceLayout == null) {
                throw new XDIMEException(EXCEPTION_LOCALIZER.format(
                        "xdime-could-not-find-layout", layoutName));
            }
        } catch (RepositoryException e) {
            // An appropriate device layout could not be found so fail.
            throw new XDIMEException(e);
        }

        DeviceLayoutContext deviceLayoutContext =
                new DeviceLayoutContext();

        DeviceLayoutContext idlc
                = pageContext.getDeviceLayoutContext();
        deviceLayoutContext.setIncludingDeviceLayoutContext(idlc);
        deviceLayoutContext.setInRegion(true);

        deviceLayoutContext.setMarinerPageContext(pageContext);
        deviceLayoutContext.setDeviceLayout(deviceLayout);
        deviceLayoutContext.initialise();
        deviceLayoutContext.setInheritableStyleValues(
                styles.getPropertyValues().createImmutablePropertyValues());

        return deviceLayoutContext;
    }

    /**
     * Return the specified container name. May be null if no container name
     * is specified (e.g. because the style value is not a {@link StyleString}.
     *
     * @param specifiedContainer
     * @return String which is the specified container name. May be null if no
     * container name is specified.
     */
    private String getSpecifiedContainerName(StyleValue specifiedContainer) {
        String containerName = null;

        if (specifiedContainer instanceof StyleString) {
            StyleString styleString = (StyleString) specifiedContainer;
            containerName = styleString.getString();
        }

        return containerName;
    }
}
