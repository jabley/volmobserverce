/*
This file is part of Volantis Mobility Server. 

Volantis Mobility Server is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Volantis Mobility Server is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Volantis Mobility Server.  If not, see <http://www.gnu.org/licenses/>. 
*/
/* ----------------------------------------------------------------------------
 * $Header: /src/voyager/com/volantis/mcs/protocols/html/XHTMLBasic.java,v 1.93 2003/04/17 10:21:07 geoff Exp $
 * ----------------------------------------------------------------------------
 * (c) Volantis Systems Ltd 2001. 
 * ----------------------------------------------------------------------------
 * Change History:
 *
 * Date         Who             Description
 * ---------    --------------- -----------------------------------------------
 * 09-Jul-01    Paul            VBM:2001062810 - Added this header, fixed
 *                              the code so that it only gets values out of
 *                              attributes once and uses append for each
 *                              separate part of the output string instead of
 *                              inline string concatenation.
 * 23-Jul-01    Paul            VBM:2001070507 - Simplified by not creating
 *                              StringBuffers when returning a fixed string
 *                              and also by renaming all the *Attributes
 *                              parameters to attributes.
 * 29-Oct-01    Paul            VBM:2001102901 - Removed unused import.
 * 22-Jan-02    Doug            VBM:2002011003 - Numerous changes to ensure
 *                              that valid XHTML Basic is generated by this
 *                              protocol. XHTMLBasic now extends
 *                              VolantisProtocol rather than XHTMLFull.
 *                              Moved much of XHTMLFull functioanlity to this
 *                              class.
 * 31-Jan-02    Paul            VBM:2001122105 - Restructured to reflect
 *                              changes to protocols.
 * 01-Feb-02    Adrian          VBM:2002013102 - modified doSelectInput to
 *                              check only for menu or not menu listf as
 *                              by definition an xfsiselect that is not menu
 *                              style must be a radiogroup.  Likewise an
 *                              xsmuselect that is not menu style must be a
 *                              checkbox group.
 * 04-Feb-02    Adrian          VBM:2002013103 - modified doSelectInput to
 *                              use new Theme attribute 'list-caption-align'.
 *                              This provides a means of specifying whether
 *                              the captions are aligned to the left or right
 *                              of each button.
 * 07-Feb-02    Adrian          VBM:2001101002 - moved generation of width
 *                              attribute on table tag in appendOpenPane to
 *                              addPaneAttributes in XHTMLFull as width is not
 *                              a valid attribute on table in HTMLBasic.
 * 13-Feb-02    Paul            VBM:2002021203 - Added getContentExtension
 *                              method.
 * 15-Feb-02    Paul            VBM:2002021203 - Rename server side include to
 *                              portlet include.
 * 19-Feb-02    Paul            VBM:2001100102 - Added the form specifier
 *                              parameter to the parameters to be sent when
 *                              submitting a form.
 * 20-Feb-02    Steve           VBM:2001101803 - Reroutes fragmented forms to
 *                              the form fragmentation servlet and adds form
 *                              fragmentation link buttons to the fragments.
 * 21-Feb-02    Payal           VBM:2002011410 - Modified appendLink()
 *                              added ">" to close Link element
 * 22-Feb-02    Payal           VBM:2002011410 - Modified appendLink()
 *                              added "/>" to close Link element
 * 28-Feb-02    Doug            VBM:2001121005 - Removed the xfIdPrefix
 *                              constant and its useage in the
 *                              createUniqueRuntimeStyle() method.
 * 28-Feb-02    Paul            VBM:2002022804 - Made methods consistent with
 *                              other StringProtocol based classes.
 * 01-Mar-02    Mat             VBM:2002021203 - Added appendSSIInclude(),
 *                              appendSSIConfig()
 * 04-Mar-02    Paul            VBM:2001101803 - Replaced a lot of duplicated
 *                              code which retrieved the initial value of a
 *                              field element with calls to getInitialValue.
 *                              Removed the getFormFragmentButton method.
 *                              Modified doActionInput due to changes to
 *                              StringProtocol.
 * 05-Mar-02    Allan           VBM:2002030102 - Modified paneNeedsTableWrapper
 *                              to check for a borderWidth of not null rather
 *                              than for a value of "0" and changed to return
 *                              true if the pane is a topLevel rather than the
 *                              other way around.
 * 05-Mar-02    Doug            VBM:2001121005 - Modified doSelectInput so that
 *                              if a list style control was being written out
 *                              the html is wrapped in a div tag so that any
 *                              style sheet can be referenced.
 * 06-Mar-02    Adrian          VBM:2002020736 - moved width attribute for all
 *                              table tags from XHTMLFull.  Moved all width
 *                              attibutes for td tags to XHTMLFull.  Moved all
 *                              valign and align for td tag to from XHTMLFull.
 * 06-Mar-02    Adrian          VBM:2002021102 - Added comment to
 *                              doMenuItemAnchor to explain that why it is okay
 *                              to output the target attribute.
 * 06-Mar-02    Adrian          VBM:2002021905 - Moved methods...
 *                              openTableHeader, addTableHeaderAttributes,
 *                              closeTableHeader, openTableBody, closeTableBody
 *                              addTableBodyAttributes, openTableFooter,
 *                              closeTableFooter, addTableFooterAttributes to
 *                              XHTMLFull as these tags are not supported in
 *                              XHTMLBasic
 * 08-Mar-02    Paul            VBM:2002030607 - Changed openLayout to write
 *                              out the style buffer which is associated with
 *                              the current device layout context. Changed
 *                              createUniqueRuntimeStyle to write the style
 *                              directly to the current buffer associated with
 *                              the device layout context rather than modifying
 *                              the device theme.
 * 11-Mar-02    Paul            VBM:2001122105 - Added some hooks to allow the
 *                              XHTMLFull protocol to add event attributes to
 *                              the menu item anchors. Also fixed up some
 *                              confusing javadoc.
 * 11-Mar-02    Doug            VBM:2002011003 - Added code to perform mappings
 *                              for certain attributes. Most mappings involve
 *                              converting the attributes value to lower case.
 *                              Fixed bug where there was a typo in the
 *                              xmlNamespace string.  Modified doImage/doTitle
 *                              so that the altText/title attribute is set to
 *                              the empty string if no value has been
 *                              specified.Moved the generation of width
 *                              attributes on td tags to the XHTMLTransitional
 *                              protocol.
 * 13-Mar-03    Allan           VBM:2002031302 - Modified openPane() to add
 *                              width to the table where specified.
 * 13-Mar-02    Paul            VBM:2002031301 - Renamed get/endContentBuffer
 *                              to get/endCurrentBuffer respectively.
 * 14-Mar-02    Steve           VBM:2002021119 - Added support for the clear
 *                              attribute in the line break tag. Added flag to
 *                              denote whether the protocol can output images
 *                              in an action tag. Added flag to denote whether
 *                              the object tag outputs a 'classid' or 'tid'
 *                              attribute.
 * 18-Mar-02    Ian             VBM:2002031203 Changed log4j Category from
 *                              class to string.
 * 21-Mar-02    Doug            VBM:2002011101 - Modified the method
 *                              createUniqueRuntimeStyle so that we do not
 *                              generate a new unique id attribute for the
 *                              element if that element already has its id
 *                              attribute set.
 * 22-Feb-02    Paul            VBM:2002021802 - Removed unused method and
 *                              updated the ssi methods.
 * 26-Mar-02    Allan           VBM:2002022007 - generateContentTree() now
 *                              takes an Object. generateContents() returns an
 *                              Object and uses ReusableStringBuffer (and
 *                              needs more work).
 * 05-Apr-02    Ian             VBM:2002030606 - Overode doForm to add mappings
 *                              of caption fields to initial values.
 * 12-Apr-02    Adrian          VBM:2002041106 - moved width attribute for all
 *                              table tags to XHTMLFull.
 * 18-Apr-02    Allan           VBM:2002041801 - Set borderWidth to 0 if this
 *                              attribute is null and the device is a Netscape
 *                              4 device. This change is done in all add..Pane
 *                              or Grid type attribute methods.
 * 25-Apr-02    Paul            VBM:2002042202 - Moved from protocols and
 *                              made it generate a DOM.
 * 26-Apr-02    Paul            VBM:2002042205 - Added a DOMTransformer to fix
 *                              up nested tables and removed the
 *                              generateContent... methods which used to do
 *                              that. Also removed all the code which renders
 *                              a simple pane as there is no need to render
 *                              any markup for a pane in this protocol. Also
 *                              changed row iterator panes to generate brs
 *                              before the pane and after each cell.
 * 02-May-02    Allan           VBM:2002040804 - Added new themes imports;
 *                              createUniqueRuntimeStyle() updated for new
 *                              style creation.
 * 28-Apr-02    Adrian          VBM:2002040808 - Added support for new
 *                              implementation of CCS emulation.
 * 02-May-02    Adrian          VBM:2002040808 - Added support for new
 *                              implementation of CCS emulation.
 * 03-May-02    Paul            VBM:2002042203 - Added support for dissection.
 * 07-May-02    Adrian          VBM:2002042302 - Removed method getContent..
 *                              ..Extension() as the cached file extension is
 *                              defined in the device policies.
 * 07-May-02    Allan           VBM:2002040804 - Modified constructor to
 *                              move style sheet renderer initialisation to the
 *                              initialise method; set this renderer based on
 *                              the value of the StyleSheetVersion property
 *                              in the current device.
 * 10-May-02    Adrian          VBM:2002040808 - Check if theme formActionStyle
 *                              has the value "link"
 * 20-May-02    Paul            VBM:2001122105 - Allowed sub classes to add
 *                              attributes to action field.
 * 20-May-02    Paul            VBM:2002042202 - Fixed problem where hidden
 *                              fields appeared before the form.
 * 21-May-02    Byron           VBM:2002042602 - Modified doMMFlash(),
 *                              doQuickTime(),  doQuickTime(),
 *                              doWindowsMedia(), to check  to see if the
 *                              device supports dynamic visuals before
 *                              generating html for it.
 * 22-May-02    Byron           VBM:2002042602 - Removed changes made on
 *                              21-May-02 and version log output in constructor.
 * 23-May-02    Steve           VBM:2002040809 - Check pane for a styleClass
 *                              attribute. If one is present, surround the pane
 *                              content with a DIV element with that styleClass.
 * 23-May-02    Paul            VBM:2002042202 - Stopped quoting attributes
 *                              as outputter does that correctly now.
 * 28-May-02    Byron           VBM:2002052307 - Modified method doWindowsMedia
 *                              to output the correct tag 'filename' instead
 *                              of 'src'
 * 05-Jun-02    Adrian          VBM:2002021103 - Open KEEPTOGETHER_ELEMENT in
 *                              method openDiv , and close in method closeDiv
 * 05-Jun-02    Byron           VBM:2002053002 - Added support for tabindex by
 *                              adding tabindex attribute to protocol output.
 *                              Added supportsTabindex attribute, and modified
 *                              openAnchor(), openObject(), doTextInput(),
 *                              doBooleanInput(), doSelectInput() and
 *                              doActionInput()
 * 07-Jun-02    Byron           VBM:2002042407 - Modified openGrid(),
 *                              openGridRow(), closeGrid(), closeGridRow(),
 *                              openGridChild(), closeGridChild(),
 * 10-Jun-02    Adrian          VBM:2002021103 - Changed keeptogether to
 *                              keepTogether.
 * 12-Jun-02    Steve           VBM:2002053005 - Added standard XHTML protocol
 *                              mappings for CSS transformations. These are set
 *                              up in the initialise method and may be altered
 *                              in derived protocols.
 * 18-Jun-02    Steve           VBM:2002040807 - Modified addCoreAttributes()
 *                              to take account of transformed CSS rules. Instead
 *                              of simply outputting a class="xxx" for an element
 *                              we now get class="VE-MarinerElement-xxx" which
 *                              will be defined in the transformed stylesheet.
 *                              The class that is generated is dependant on the
 *                              setting of the css.multiclass.support entry for
 *                              the device.
 * 17-Jun-02    Byron           VBM:2002042407 - Removed modifications done on
 *                              07-Jun-02 mentioned above.
 * 17-Jun-02    Byron           VBM:2002061001 - Changed capitalisation for
 *                              xxxxtabindex
 * 19-Jun-02    Adrian          VBM:2002053104 - added methods paneHasStyle..
 *                              ..Attributes, getLayoutDeviceThemeFactory.
 *                              Updated open..Pane methods to write style class
 *                              attributes on pane tag to enable writing of
 *                              appropriate styles from DeviceLayout stylesheet
 * 21-Jun-02    Paul            VBM:2002061202 - Modified getDOMTransformer and
 *                              getDissector to always return an object,
 *                              even for sub classes.
 * 25-Jun-02    Steve           VBM:2002040809 - If the pane is enclosed within
 *                              a <td> element and has a style attribute then
 *                              the <td> element is given the same style
 *                              attribute as the pane.
 * 26-Jun-02    Steve           VBM:2002040809 - Fixed bug in the previous fix
 *                              where the parent element does not have a name
 *                              eg when the pane is not wrapped inside a grid.
 *                              In that instance, a null pointer exception
 *                              occurred when checking the name of the parent.
 * 26-Jun-02    Steve           VBM:2002040807 - ignore case of support strings
 * 27-Jun-02    Byron           VBM:2002062501 - Added supportsDissectingPanes
 *                              attribute. Modified open/close DissectingPane
 *                              methods to use supportsDissectingPanes
 * 28-Jun-02    Paul            VBM:2002051302 - Removed unnecessary import
 *                              and changed to use StyleProperties
 *                              instead of StylePropertiesCollection.
 * 3-Jul-02     Steve           VBM:2002062602 - Do not generate VE-class
 *                              classes if no theme is attached to the page.
 *                              This is simply a case of checking whether the
 *                              page context has a Device Theme set when
 *                              generating the class attribute for elements.
 * 01-Jul-02    Steve           VBM:2002062401 - Allow for captionPane, entryPane
 *                              and captionClass attributes on xfoption tag
 * 09-Jul-02    Steve           VBM:2002040807 - Removed the 4 parameter version
 *                              of addCoreAttributes() which was added under this
 *                              VBM as the tag attribute already holds the mariner
 *                              element name. The code from the 4 parameter version
 *                              has therefore been shifted to work under the 3
 *                              parameter version. All calls to the 4 parameter
 *                              version have been shifted back to call the old
 *                              method.
 * 12-Jul-02    Byron           VBM:2002071204 - Removed openLayout(),
 *                              createUniqueRuntimeStyle() and any calls made
 *                              to them.
 * 12-Jul-02    Byron           VBM:2002071204 - Removed extraneous debug
 *                              statements.
 * 15-Jul-02    Adrian          VBM:2002053104 - Reimplemented this task after
 *                              code was removed under 2002040807.  Updated
 *                              addCoreAttributes to take an alternate style
 *                              class name as a parameter.  Moved openInclusion
 *                              and closeInclusion from XHTMLFull.  updated all
 *                              open/close..Pane methods.
 * 22-Jul-02    Adrian          VBM:2002071906 - Updated method openBody to
 *                              call addCoreAttributes with false for title
 *                              flag parameter.
 * 24-Jul-02    Adrian          VBM:2002072402 - updated method doLink to
 *                              use addElement instead of openElement as this
 *                              is a do.. method rather than part of an open..
 *                              close.. pair so closeElement was never called.
 * 26-Jul-02    Steve           VBM:2002062401 - xfoption uses a <span> to
 *                              surround captions so that line breaks are not
 *                              output by some browsers when using <div>.
 *                              Also, the caption was being generated twice if
 *                              it was in the same pane as the control and
 *                              aligned to the right of the control.
 * 26-Jul-02    Steve           VBM:2002040807 - moved the protocol element
 *                              mapping initialisation into the class
 *                              constructor and out of initialise() so that
 *                              it only gets called once. Re-removed the four
 *                              parameter version of addCoreAttributes() which
 *                              was removed pn 9/7/02 but seems to have found
 *                              its way back. Instead of querying the device
 *                              to check if style sheet support is possible
 *                              addClassAttribute() uses the inline and
 *                              external style sheet support flags to do the
 *                              same thing which is less expensive. This method
 *                              also uses isInclusion() to determine whether
 *                              portal or portlet elements should be mapped.
 *                              If the device theme we are converting has its
 *                              own stylesheet then no conversion is done.
 * 29-Jul-02    Byron           VBM:2002061005 - Modified doRealMedia to 'src'
 *                              to output as 'filename' and not 'src'
 * 27-Jul-02    Adrian          VBM:2002072407 - updated method addClass..
 *                              ..Attribute to test for supportsMultiple..
 *                              ..AttributeClasses flag instead of
 *                              supportsMultipleSelectorClasses.
 * 31-Jul-02    Paul            VBM:2002073008 - Implemented package methods
 *                              just to make sure that it generates valid HTML,
 *                              this does not constitute proper support for
 *                              packages in HTML.
 * 01-Aug-02    Sumit           VBM:2002073109 - optgroup support added. Moved
 *                              option manupilation into recursive functions
 *                              and changed doSelectInput to use them
 * 06-Aug-02    Paul            VBM:2002073008 - Removed support for package
 *                              element.
 * 09-Aug-02    Sumit           VBM:2002080732 - altered method
 *                              addClassAttribute to generate the correct
 *                              markup for multiple attributes without multiple
 *                              classes
 * 12-Aug-02    Sumit           VBM:2002081206 - added maxLength attribute for
 *                              <input> in doTextInput()
 * 15-Aug-02    Paul            VBM:2002081421 - Added support for xfactions
 *                              being outside the form. Moved the code which
 *                              retrieves the image asset url for an image
 *                              xfaction into a separate method.
 * 16-Aug-02    Phil W-S        VBM:2002081507 - Added in a multiple element
 *                              mapping for xfaction to allow the CSS renderer
 *                              to render xfaction selector rules.
 * 16-Aug-02    Adrian          VBM:2002081214 - modified addClassAttribute to
 *                              prevent writing empty styleClass values.
 * 16-Aug-02    Adrian          VBM:2002081214 - modified addClassAttribute to
 *                              fix bug in change above.
 * 20-Aug-02    Adrian          VBM:2002081316 - Updated doImage to output
 *                              altText in span tag if the image source is null
 * 27-Aug-02    Byron           VBM:2002081907 - Modified addCoreAttributes
 *                              with improved algorithm. Added method
 *                              peformSelectorTransformation(), removed some
 *                              commented out code and added unit testing for
 *                              modified algorithm (see unit test framework)
 * 04-Sep-02    Byron           VBM:2002081907 - peformSelectorTransformation()
 *                              modified with minor fixes
 * 09-Sep-02    Byron           VBM:2002081907 - peformSelectorTransformation()
 *                              modified with minor fixes. Renamed it to
 *                              peformSelectorTransformation()
 * 10-Sep-02    Steve           VBM:2002040809 - Modifications for seeting
 *                              pane attributes using new theme/attribute
 *                              method in VolantisProtocol
 * 10-Oct-02    Adrian          VBM:2002100404 - added method getPaneStyleClass
 *                              and updated open..Pane methods to use the new
 *                              method instead of context.getPaneStyleClass
 * 16-Oct-02    Byron           VBM:2002101605 - Added useNobreakStyleForTag and
 *                              VP_NOBREAK attributes. Renamed misspelt method
 *                              peformSelectorTransformation
 * 17-Oct-02    Phil W-S        VBM:2002081322 - Make addClassAttribute
 *                              accessible by specializations and created the
 *                              addCoreAttributesNobreak method for use here
 *                              and in specializations.
 * 21-Oct-02    Byron           VBM:2002100401 - Modified doSelectinInput
 *                              to copy the attributes before updating them.
 *                              Removed redundant imports, fixed javadoc
 *                              errors, removed unused variables in several
 *                              methods. Added to do item for deprecated methods
 *                              used.
 * 08-Nov-02    Phil W-S        VBM:2002102306 - Update
 *                              performSelectorTransformation to use the
 *                              new themeContainsElementRule method which
 *                              enables optimized addition of the VE-tag
 *                              style class references in the DOM output.
 * 12-Nov-02    Phil W-S        VBM:2002111208 - Make doShardLink add a
 *                              fixed style class to the anchor, called
 *                              "shardlinks".
 * 19-Nov-02    Byron           VBM:2002110517 - Refactored doActionInput
 *                              by adding method createActionElement() which
 *                              is overridden by the HTMLParagon protcol.
 * 25-Nov-02    Phil W-S        VBM:2002111808 - Updated openDissectingPane and
 *                              closeDissectingPane to be 1) balanced if
 *                              the device doesn't have a max html page size
 *                              specified and 2) formed using the same
 *                              conditional expressions and basic structure.
 * 18-Nov-02    Geoff           VBM:2002111504 - Refactored to use new fallback
 *                              methods in the page context, cleaned up javadoc
 *                              and imports.
 * 04-Dec-02    Phil W-S        VBM:2002111208 - Removed previous fix in
 *                              doShardLink and added handling of the new
 *                              previous and next shard link style class
 *                              attributes in openDissectingPane.
 * 05-Dec-02    Byron           VBM:2002120304 - Moving alignMappings,
 *                              valignMappings and getMapping() to new class
 *                              XHTMLBasicAlignMappings. Modified
 *                              getAlignMapping() and getValginMapping() to use
 *                              new class' methods.
 * 12-Dec-02    Phil W-S        VBM:2002110516 - Change openGrid to handle
 *                              style classes, added gridHasStyleAttributes and
 *                              refactored getPaneStyleClass to make it
 *                              applicable to any type of format.
 * 16-Dec-02    Adrian          VBM:2002100203 - Added more comprehensive
 *                              javadoc to constructor where elementMappings
 *                              field is populated. Made span a multiple
 *                              elementMapping from span, img, and xfoption.
 *                              Added xfoption as a another key to input tag.
 *                              Fixed entries for xfform and canvas. Updated
 *                              references to supportsMultipleStyleClasses to
 *                              supportsMultipleSelectorClasses.
 * 18-Dec-02    Phil W-S        VBM:2002121601 - Ensure that the right layout
 *                              is used when caching style classes in
 *                              getFormatStyleClass.
 * 16-Dec-02    Adrian          VBM:2002100203 - Add elementMapping for
 *                              "xfoption" to "option" as a multiple instead of
 *                              singular mapping
 * 15-Jan-03    Phil W-S        VBM:2002110402 - Rework: use the unabridged
 *                              transformer. Changes getDOMTransformer.
 * 20-Jan-03    Geoff           VBM:2003011616 - refactored duplicate code in
 *                              doTextInput, doBooleanInput into new method
 *                              addFormFieldAccessKeyAttribute, and added call
 *                              to it in addActionAttributes.
 * 22-Jan-03    Doug            VBM:2002120213 - Rewrote the doSelectInput()
 *                              method. This involved removing numerous
 *                              supporting methods.
 *                              Add the inner SelectionRender classes.
 * 23-Jan-03    Byron           VBM:2003012211 - Added xml definition in
 *                              doProtocolString.met
 * 23-Jan-03    Doug            VBM:2003012304 - Fully qualified all access
 *                              to the VolantisProtocol mehtods from the
 *                              SelectionRenderer inner classes.
 * 27-Jan-03    Byron           VBM:2003012404 - Remove useNobreakStyleForTag
 *                              attribute and addCoreAttributesNobreak method.
 * 27-Jan-03    Doug            VBM:2003012718 - Fixed a menu orientation
 *                              problem in the the initialise() method of the
 *                              ControlSelectionRenderer inner class.
 * 29-Jan-03    Byron           VBM:2003012803 - Modified constructor to set
 *                              protocolConfiguration value and any static
 *                              variables dependent on it.
 * 13-Feb-03    Byron           VBM:2003021309 - Provided implemenation for
 *                              getPackagingType
 * 06-Mar-03    Sumit           VBM:2003022605 - Implemented openSpatial...()
 *                              to allow for format specific processing
 * 14-Mar-03    Doug            VBM:2003030409 - Modified openDisectingPane()
 *                              to write out the
 *                              GENERATE_NEXT_LINK_FIRST_ATTRIBUTE attribte.
 *                              Added the isDissectionSupported() method.
 * 20-Mar-03    sumit           VBM:2003031809 - Wrapped logger.debug
 *                              statements in if(logger.isDebugEnabled()) block
 * 21-Mar-03    Byron           VBM:2003031907 - Modified openDissectingPane to
 *                              use updated text for shards.
 * 25-Mar-03    Steve           VBM:2003031907 - If the previous/next shard
 *                              link text has not been overridden, read it from
 *                              the pane format in the layout.
 * 28-Mar-03    Geoff           VBM:2003031711 - Add overload of renderAltText
 *                              to use span instead of p to enclose the text.
 * 01-Apr-03    Phil W-S        VBM:2002111502 - Override openPhoneNumber and
 *                              closePhoneNumber and add new
 *                              addPhoneNumberAttributes method.
 * 08-Apr-03    Sumit           VBM:2003032713 - Added render support for menu
 *                              item groups
 * 16-Apr-03    Geoff           VBM:2003041603 - Add declaration for
 *                              ProtocolException where necessary.
 * 25-Apr-03    Steve           VBM:2003041606 - EncodingWriter is now an
 *                              OutputBufferWriter
 * 09-May-03    Byron           VBM:2003042205 - Renamed gridHasStyleAttributes
 *                              and changed paramater type from Grid to Format.
 *                              Added openSpatialFormatIteratorOriginal,
 *                              furnishElementStyle(..). Modified
 *                              openSpatialFormatIterator
 * 23-May-03    Mat             VBM:2003042907 - Renamed getXMLOutputter() to
 *                              getDocumentOutputter()
 * 28-May-03    Mat             VBM:2003042911 - Changed to use outputter instead
 *                              of outputterWriter
 * ----------------------------------------------------------------------------
 */

package com.volantis.mcs.protocols.html;

import com.volantis.mcs.context.TranscodableUrlResolver;
import com.volantis.mcs.css.mappers.TextAlignKeywordMapper;
import com.volantis.devrep.repository.api.devices.DevicePolicyConstants;
import com.volantis.mcs.devices.InternalDevice;
import com.volantis.mcs.dom.DocType;
import com.volantis.mcs.dom.Document;
import com.volantis.mcs.dom.Element;
import com.volantis.mcs.dom.MarkupFamily;
import com.volantis.mcs.dom.Node;
import com.volantis.mcs.dom.NodeSequence;
import com.volantis.mcs.expression.PolicyExpression;
import com.volantis.mcs.layouts.DissectingPane;
import com.volantis.mcs.localization.LocalizationFactory;
import com.volantis.mcs.policies.variants.text.TextEncoding;
import com.volantis.mcs.protocols.AddressAttributes;
import com.volantis.mcs.protocols.AnchorAttributes;
import com.volantis.mcs.protocols.BlockQuoteAttributes;
import com.volantis.mcs.protocols.BodyAttributes;
import com.volantis.mcs.protocols.CanvasAttributes;
import com.volantis.mcs.protocols.CaptionAttributes;
import com.volantis.mcs.protocols.CiteAttributes;
import com.volantis.mcs.protocols.CodeAttributes;
import com.volantis.mcs.protocols.ColumnIteratorPaneAttributes;
import com.volantis.mcs.protocols.DOMOutputBuffer;
import com.volantis.mcs.protocols.DOMProtocol;
import com.volantis.mcs.protocols.DOMTransformer;
import com.volantis.mcs.protocols.DefinitionDataAttributes;
import com.volantis.mcs.protocols.DefinitionListAttributes;
import com.volantis.mcs.protocols.DefinitionTermAttributes;
import com.volantis.mcs.protocols.DissectingPaneAttributes;
import com.volantis.mcs.protocols.DivAttributes;
import com.volantis.mcs.protocols.EmphasisAttributes;
import com.volantis.mcs.protocols.EventAttributes;
import com.volantis.mcs.protocols.EventConstants;
import com.volantis.mcs.protocols.FormAttributes;
import com.volantis.mcs.protocols.GridAttributes;
import com.volantis.mcs.protocols.GridChildAttributes;
import com.volantis.mcs.protocols.GridRowAttributes;
import com.volantis.mcs.protocols.HeadingAttributes;
import com.volantis.mcs.protocols.HorizontalRuleAttributes;
import com.volantis.mcs.protocols.ImageAttributes;
import com.volantis.mcs.protocols.KeyboardAttributes;
import com.volantis.mcs.protocols.LineBreakAttributes;
import com.volantis.mcs.protocols.ListItemAttributes;
import com.volantis.mcs.protocols.MCSAttributeStylePropertyFilter;
import com.volantis.mcs.protocols.MCSAttributes;
import com.volantis.mcs.protocols.MenuAttributes;
import com.volantis.mcs.protocols.MenuItem;
import com.volantis.mcs.protocols.MetaAttributes;
import com.volantis.mcs.protocols.NativeMarkupAttributes;
import com.volantis.mcs.protocols.ObjectAttribute;
import com.volantis.mcs.protocols.Option;
import com.volantis.mcs.protocols.OptionVisitor;
import com.volantis.mcs.protocols.OrderedListAttributes;
import com.volantis.mcs.protocols.OutputBuffer;
import com.volantis.mcs.protocols.OutputBufferWriter;
import com.volantis.mcs.protocols.PaneAttributes;
import com.volantis.mcs.protocols.ParagraphAttributes;
import com.volantis.mcs.protocols.PhoneNumberAttributes;
import com.volantis.mcs.protocols.PreAttributes;
import com.volantis.mcs.protocols.ProtocolConfiguration;
import com.volantis.mcs.protocols.ProtocolException;
import com.volantis.mcs.protocols.ProtocolSupportFactory;
import com.volantis.mcs.protocols.ProtocolWriter;
import com.volantis.mcs.protocols.RowIteratorPaneAttributes;
import com.volantis.mcs.protocols.SampleAttributes;
import com.volantis.mcs.protocols.Script;
import com.volantis.mcs.protocols.SelectOption;
import com.volantis.mcs.protocols.SelectOptionGroup;
import com.volantis.mcs.protocols.SelectionRenderer;
import com.volantis.mcs.protocols.ShardLinkAttributes;
import com.volantis.mcs.protocols.SpanAttributes;
import com.volantis.mcs.protocols.SpatialFormatIteratorAttributes;
import com.volantis.mcs.protocols.StrongAttributes;
import com.volantis.mcs.protocols.SubscriptAttributes;
import com.volantis.mcs.protocols.SuperscriptAttributes;
import com.volantis.mcs.protocols.TableAttributes;
import com.volantis.mcs.protocols.TableCellAttributes;
import com.volantis.mcs.protocols.TableRowAttributes;
import com.volantis.mcs.protocols.TimedRefreshInfo;
import com.volantis.mcs.protocols.UnorderedListAttributes;
import com.volantis.mcs.protocols.XFActionAttributes;
import com.volantis.mcs.protocols.XFBooleanAttributes;
import com.volantis.mcs.protocols.XFFormAttributes;
import com.volantis.mcs.protocols.XFFormFieldAttributes;
import com.volantis.mcs.protocols.XFImplicitAttributes;
import com.volantis.mcs.protocols.XFSelectAttributes;
import com.volantis.mcs.protocols.XFTextInputAttributes;
import com.volantis.mcs.protocols.XFUploadAttributes;
import com.volantis.mcs.protocols.assets.AssetReferenceException;
import com.volantis.mcs.protocols.assets.ImageAssetReference;
import com.volantis.mcs.protocols.assets.LinkAssetReference;
import com.volantis.mcs.protocols.assets.ScriptAssetReference;
import com.volantis.mcs.protocols.assets.TextAssetReference;
import com.volantis.mcs.protocols.assets.implementation.AssetResolver;
import com.volantis.mcs.protocols.assets.implementation.DefaultComponentImageAssetReference;
import com.volantis.mcs.protocols.assets.implementation.LiteralTextAssetReference;
import com.volantis.mcs.protocols.css.CSSModule;
import com.volantis.mcs.protocols.css.emulator.CSSConstants;
import com.volantis.mcs.protocols.css.renderer.RuntimeCSSStyleSheetRenderer;
import com.volantis.mcs.protocols.dissection.DissectionConstants;
import com.volantis.mcs.protocols.forms.ActionFieldType;
import com.volantis.mcs.protocols.forms.EmulatedXFormDescriptor;
import com.volantis.mcs.protocols.forms.FieldDescriptor;
import com.volantis.mcs.protocols.forms.FieldHandler;
import com.volantis.mcs.protocols.gallery.GalleryModule;
import com.volantis.mcs.protocols.hr.HorizontalRuleEmulator;
import com.volantis.mcs.protocols.hr.HorizontalRuleEmulatorFactory;
import com.volantis.mcs.protocols.html.menu.XHTMLBasicMenuModuleRendererFactory;
import com.volantis.mcs.protocols.html.xhtmlbasic.XHTMLBasicTableCellVerticalAlignKeywordMapper;
import com.volantis.mcs.protocols.layouts.ContainerInstance;
import com.volantis.mcs.protocols.menu.MenuModule;
import com.volantis.mcs.protocols.menu.MenuModuleRendererFactory;
import com.volantis.mcs.protocols.menu.MenuModuleRendererFactoryFilter;
import com.volantis.mcs.protocols.menu.shared.DefaultMenuModule;
import com.volantis.mcs.protocols.styles.IntegerHandler;
import com.volantis.mcs.protocols.styles.KeywordValueHandler;
import com.volantis.mcs.protocols.styles.NoopPropertyUpdater;
import com.volantis.mcs.protocols.styles.PositivePixelLengthOrPercentageHandler;
import com.volantis.mcs.protocols.styles.PropertyClearer;
import com.volantis.mcs.protocols.styles.PropertyExcluder;
import com.volantis.mcs.protocols.styles.PropertyHandler;
import com.volantis.mcs.protocols.styles.TextAlignHandler;
import com.volantis.mcs.protocols.styles.ValueHandlerToPropertyAdapter;
import com.volantis.mcs.protocols.ticker.TickerModule;
import com.volantis.mcs.protocols.ticker.response.TickerResponseModule;
import com.volantis.mcs.protocols.widgets.WidgetModule;
import com.volantis.mcs.protocols.widgets.XHTMLBasicWidgetModule;
import com.volantis.mcs.repository.RepositoryException;
import com.volantis.mcs.runtime.URLConstants;
import com.volantis.mcs.runtime.policies.PolicyReferenceResolver;
import com.volantis.mcs.runtime.policies.RuntimePolicyReference;
import com.volantis.mcs.themes.StyleComponentURI;
import com.volantis.mcs.themes.StylePropertyDetails;
import com.volantis.mcs.themes.StyleTranscodableURI;
import com.volantis.mcs.themes.StyleURI;
import com.volantis.mcs.themes.StyleValue;
import com.volantis.mcs.themes.StyleValueType;
import com.volantis.mcs.themes.properties.DisplayKeywords;
import com.volantis.mcs.themes.properties.MCSFormActionStyleKeywords;
import com.volantis.mcs.themes.properties.MCSImageKeywords;
import com.volantis.mcs.themes.properties.MCSMenuOrientationKeywords;
import com.volantis.mcs.themes.properties.MCSSelectionListOptionLayoutKeywords;
import com.volantis.mcs.themes.properties.MCSSelectionListStyleKeywords;
import com.volantis.mcs.utilities.WhitespaceUtilities;
import com.volantis.shared.throwable.ExtendedRuntimeException;
import com.volantis.styling.StyleContainer;
import com.volantis.styling.Styles;
import com.volantis.styling.StylingFactory;
import com.volantis.styling.properties.StyleProperty;
import com.volantis.styling.values.MutablePropertyValues;
import com.volantis.styling.values.PropertyValues;
import com.volantis.synergetics.log.LogDispatcher;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 *
 * This is a sub-class of the VolantisProtocol class to provide the precise
 * definition of the XHTML Basic protocol.
 *
 * XHTML supports style sheets, so no themes processing is performed here.
 *
 */
public class XHTMLBasic extends DOMProtocol
        implements CSSConstants,
                   HTMLConstants,
                   DissectionConstants {

    /**
     * Used for logging
     */
    private static final LogDispatcher logger =
            LocalizationFactory.createLogger(XHTMLBasic.class);


    /**
     * The names of the different heading elements indexed by their level.
     */
    private static final String [] headingElementNames = new String [] {
        null, "h1", "h2", "h3", "h4", "h5", "h6",
    };
    
    /**
     * Collection of invalid form parents tag names
     */
    private static final List invalidFormParents = Collections
            .unmodifiableList(new ArrayList() {
                {
                    addAll(Arrays.asList(HTMLConstants.INLINE_ELEMENTS));
                    add("td");
                    add("tr");
                }
            });

    /**
     * Flag to indicate whether the protocol requires that the
     * img tag writes out a alt attribute
     */
    protected boolean altTextForImgRequired = true;

    /**
     * Flag to indicate whether the protocol allows the img tag to write
     * out a localsrc attribute
     */
    protected boolean supportsLocalSourceImg = false;

    // todo this should be a typesafe enumeration ???
    protected static final int ROLLOVER_IMAGE_MENU_ITEM = 0;
    protected static final int ROLLOVER_TEXT_MENU_ITEM = 1;
    private static final int PLAIN_MENU_ITEM = 2;

    /**
     * Flag to denote whether the protocol supports image buttons
     */
     protected boolean supportsImageButtons;

    /**
     * The xml namespace to use in the head.
     */
    protected String xmlNamespace;

    /**
     * Specifies if this version of HTML supports a title attribute on
     * the TR tag.
     */
    protected boolean supportsTitleOnInput = true;

    /**
     * Specifies if this version of HTML supports a title attribute on
     * the TD tag.
     */
    protected boolean supportsTitleOnOption = true;


    /**
     * Specifies if this version of HTML supports a title attribute on
     * the optgroup tag
     */
    private final boolean supportsTitleOnOptionGroup = true;

    /**
     * Specifies if this protocol may support tabindex attribute
     */
    protected final boolean supportsTabindex = true;

    /**
     * Specifies if this protocol may support dissecting panes attribute
     */
    protected boolean supportsDissectingPanes = false;

    /**
     * Specifies if this protocol should generate a markup name attribute from
     * the input id attribute. This is useful if the device does not support
     * "internal" links (i.e. fragment identifiers) targetting elements using
     * their id attribute.
     * <p>
     * Generally speaking, this must be set if the device/protocol does not
     * support id for targetting but does support name for targetting. This
     * happens in various scenarios, for example in HTML 3.2 protocols which
     * do not support id at all, and in dodgy devices which claim to support
     * XHTMLBasic or HTML 4 but in fact work like HTML 3.2 for targetting
     * purposes, even though they support id for styles.
     * <p>
     * Note that this does not control the generation of the markup id
     * attribute from the input id attribute, this is handled in
     * {@link #addCoreAttributes} and it's various overrides.
     * <p>
     * In future it may be an idea to refactor the handling of the id attribute
     * and combine the handling of id and name generation in one place.
     * <p>
     * It would also be nice to make this a device policy, so we could avoid
     * writing out the redundant name attribute for those devices which use
     * a protocol which has this turned on and does implement id targetting.
     * <p>
     * The "Modularization of XHTML" spec for details on the Name
     * Identification Module which this was named after. Note that this Module
     * identifies seven elements which may have a name, but we are only
     * interested in those which may be used for targetting. So, for now we
     * have only implemented it for the anchor and image tags. Finding which
     * tags are usable for targetting is possibly not easy given it comes from
     * HTML 3.2 which was poorly defined in the first place.
     */
    protected boolean enableNameIdentification = false;

    /**
     * Specifies the optgroup depth this protocol supports. Default is 0
     * i.e. no optgroup support
     */
    protected int maxOptgroupDepth = 0;

    /**
     * Variable used to store away the current nesting depth for
     * generated optgroups.
     */
    private int currentOptgroupDepth = 0;

    /**
     * SelectionRender for rendering select menu lists
     */
    private SelectionRenderer defaultSelectionRenderer;

    /**
     * SelectionRender for rendering control (checkboxes/radio button)
     * select controls
     */
    private SelectionRenderer controlSelectionRenderer;

    /**
     * This variable is used to hold the caption which was retrieved from the
     * image components caption. It should only be accessed immediately after
     * a call to getActionImageURL has returned null.
     */
    private String actionImageCaption;

    /**
     * This Set stores the css property that we need to emulate. The elements
     * in this set should be constants taken from the CSSConstants interface.
     * This Set is populated by the setUpCssEmulation() method
     */
    protected final Set cssEmulation;

    /**
     * Use this to handle text align style values.
     */
    protected PropertyHandler horizontalAlignChecker;
    protected PropertyHandler horizontalAlignHandler;

    protected PropertyHandler verticalAlignHandler;

    private PropertyHandler widthChecker;
    protected PropertyHandler widthHandler;
    protected PropertyHandler tableWidthChecker;
    protected PropertyHandler tableWidthHandler;

    protected PropertyHandler heightChecker;
    protected PropertyHandler heightHandler;

    private PropertyHandler mcsRowsHandler;
    private PropertyHandler mcsColumnsHandler;

    /**
     * This array defines the names of all the event attributes. It must
     * match the EventConstants values which is why each element is initialised
     * explicitly.
     */
    protected static final String [] eventAttributeNames
        = new String [EventConstants.MAX_EVENTS];

    static {
        eventAttributeNames [EventConstants.ON_CLICK] = "onclick";
        eventAttributeNames [EventConstants.ON_DOUBLE_CLICK] = "ondblclick";
        eventAttributeNames [EventConstants.ON_KEY_DOWN] = "onkeydown";
        eventAttributeNames [EventConstants.ON_KEY_PRESS] = "onkeypress";
        eventAttributeNames [EventConstants.ON_KEY_UP] = "onkeyup";
        eventAttributeNames [EventConstants.ON_MOUSE_DOWN] = "onmousedown";
        eventAttributeNames [EventConstants.ON_MOUSE_MOVE] = "onmousemove";
        eventAttributeNames [EventConstants.ON_MOUSE_OUT] = "onmouseout";
        eventAttributeNames [EventConstants.ON_MOUSE_OVER] = "onmouseover";
        eventAttributeNames [EventConstants.ON_MOUSE_UP] = "onmouseup";
        eventAttributeNames [EventConstants.ON_LOAD] = "onload";
        eventAttributeNames [EventConstants.ON_UNLOAD] = "onunload";
        eventAttributeNames [EventConstants.ON_FOCUS] = "onfocus";
        eventAttributeNames [EventConstants.ON_BLUR] = "onblur";
        eventAttributeNames [EventConstants.ON_SUBMIT] = "onsubmit";
        eventAttributeNames [EventConstants.ON_RESET] = "onreset";
        eventAttributeNames [EventConstants.ON_CHANGE] = "onchange";
        eventAttributeNames [EventConstants.ON_SELECT] = "onselect";
    }

    /**
     * Tag name used when writing out implicit content.
     */
    private static final String IMPLICIT_ELEMENT = "input";

    /**
     * Tag name used when writing out form emulation elements.
     */
    private static final String FORM_EMULATION_ELEMENT = "form";

    /**
     * The <code>Writer</code> to use to write pre encoded text to the current
     * output buffer.
     */
    private OutputBufferWriter directWriter;

    
    /**
     * Hold reference to widget module - there is no point in creating
     * new widget instance for each widget markup on page, so widget module
     * should be created per request
     */
    private XHTMLBasicWidgetModule widgetModule = null;
    
    /**
     * Hold reference to ticker module - there is no point in creating
     * new widget instance for each ticker element markup on page, so ticker module
     * should be created per request
     */
    private TickerModule tickerModule = null;
    
    /**
     * Hold reference to gallery module - there is no point in creating
     * new widget instance for each gallery element markup on page, so gallery module
     * should be created per request
     */
    private GalleryModule galleryModule = null;
    
    /**
     * A map containing all processed form field attributes, keyed by its ID.
     * This is currently used by WidgetModule in case of multiple validators.
     */
    private Map formFieldRegistryMap;
    
    /**
     * Initialise this object.
     *
     * @param supportFactory The factory used by the protocol to obtain support
     * objects.
     * @param configuration The protocol specific configuration.
     */
    public XHTMLBasic(ProtocolSupportFactory supportFactory,
                     ProtocolConfiguration configuration) {
        
        super(supportFactory, configuration);

        styleSheetRenderer = RuntimeCSSStyleSheetRenderer.getSingleton();

        // Define the default accesskey attribute support for this protocol
        // family
        supportsAccessKeyAttribute = true;

        // Supports external style sheets but not inline styles.
        supportsExternalStyleSheets = true;

        // Supports 'image' type on action inputs
        supportsImageButtons = true;

        // Supports classid in Object tags

        xmlNamespace = "http://www.w3.org/1999/xhtml";

        supportsDissectingPanes = true;

        // XHTML protocols support fragmentation.
        supportsFragmentation = true;

        /**
         * XHTMLBasic needs to use div for menus because it does not support
         * span.
         */
        usesDivForMenus = true;

        // Populate the set of emulated css properties
        cssEmulation = new HashSet();
        setUpCssEmulation();

        // Set the protocol default for nested table support to false.
        // This may be updated by the initialise method depending on the
        // value in the device database.
        supportsNestedTables = false;
    }

    /**
     * Populate the set of emulated css properties.
     */
    protected void setUpCssEmulation() {
        // At the moment only HTMLVersion4_0_NS4 and HTMLVersion4_0_IE need to
        // put values in the cssEmulation Set.
    }

    /**
     * Initialise the protocol. This is called after the context has been
     * initialised so it can be queried for information.
     */
    public void initialise () {
        super.initialise ();


        // Get the maximum page size.
        String value = context.getDevicePolicyValue (MAX_HTML_PAGE_SIZE);
        maxPageSize = -1;
        if (value != null) {
            try {
                maxPageSize = Integer.parseInt (value);
            }
            catch (NumberFormatException nfe) {
            }
        }



        // Some protocol variants support automatic shortcut prefix display
        supportsAutomaticShortcutPrefixDisplay =
                supportsAccessKeyAttribute &&
                context.getDevice().getBooleanPolicyValue(
                        DevicePolicyConstants.
                        SUPPORTS_XHTML_ACCESSKEY_AUTOMAGIC_NUMBER_DISPLAY);

        
        // In future we may refactor the code below to use the factory pattern,
        // but for now there is no need for it, as we have only one implementation
        // of widget module and do not plan to add more any time soon.
        try {
            widgetModule = (XHTMLBasicWidgetModule) Class
                .forName("com.volantis.mcs.protocols.widgets.WidgetDefaultModule")
                .newInstance();
        } catch (Exception e) {
            // Log the warning, but do not stop processing, just behave 
            // as if widgets were not supported by this protocol
            logger.warn("cannot-instantiate-widget-module", e);
        } 

        try {
            tickerModule = (TickerModule) Class
                .forName("com.volantis.mcs.protocols.ticker.TickerDefaultModule")
                .newInstance();
        } catch (Exception e) {
            // Log the warning, but do not stop processing, just behave 
            // as if ticker is not supported by this protocol
            logger.warn("cannot-instantiate-ticker-module", e);
        } 

        try {
            galleryModule = (GalleryModule) Class
                .forName("com.volantis.mcs.protocols.gallery.GalleryDefaultModule")
                .newInstance();
        } catch (Exception e) {
            // Log the warning, but do not stop processing, just behave 
            // as if gallery is not supported by this protocol
            logger.warn("cannot-instantiate-gallery-module", e);
        } 
    }

    // Javadoc inherited.
    protected void initialiseStyleHandlers() {
        super.initialiseStyleHandlers();

        // TODO: Maybe we should be using the NoopPropertyClearer as the
        // default rather than PropertyClearer? Need to think more about this.

        // Initialise the style value handlers.
        KeywordValueHandler textAlignKeywordHandler = new KeywordValueHandler(
                TextAlignKeywordMapper.getSingleton());

        horizontalAlignChecker = new TextAlignHandler(
                textAlignKeywordHandler,
                NoopPropertyUpdater.getDefaultInstance());

        // NOTE: do not attempt to use the NoopPropertyClearer here without due
        // thought. I tried it on the Orange OAT pagination.oml and the
        // pagination buttons stopped rendering properly. The right side of
        // the pagination is in a right aligned table cell (as shown below with
        // [] meaning a table and | a cell separator)
        // [ [ < | prev ]                                        [ next | > ] ]
        // stopped rendering properly, the sub table  [ next | > ] was not right
        // aligned in the parent table's td. This is because when you leave in
        // the text-align: on the td, it apparently overrides the align= and
        // has a slightly different meaning, whereby to get the "next >" right
        // aligned you need to add width: 100% on the table that surrounds it.
        // Not sure how we should address this in future, but we shouldn't be
        // relying on such nastyness...
        horizontalAlignHandler = new TextAlignHandler(
                textAlignKeywordHandler,
                PropertyExcluder.getDefaultInstance());

        verticalAlignHandler = new ValueHandlerToPropertyAdapter(
                StylePropertyDetails.VERTICAL_ALIGN,
                new KeywordValueHandler(XHTMLBasicTableCellVerticalAlignKeywordMapper
                                .getDefaultInstance()),
                PropertyClearer.getDefaultInstance());

        widthChecker = new ValueHandlerToPropertyAdapter(
                StylePropertyDetails.WIDTH,
                new PositivePixelLengthOrPercentageHandler(),
                new NoopPropertyUpdater());
        widthHandler = new ValueHandlerToPropertyAdapter(
                StylePropertyDetails.WIDTH,
                new PositivePixelLengthOrPercentageHandler(),
                PropertyClearer.getDefaultInstance());
        tableWidthChecker = new ValueHandlerToPropertyAdapter(
                StylePropertyDetails.WIDTH,
                new PositivePixelLengthOrPercentageHandler(100),
                new NoopPropertyUpdater());
        tableWidthHandler = new ValueHandlerToPropertyAdapter(
                StylePropertyDetails.WIDTH,
                new PositivePixelLengthOrPercentageHandler(100),
                PropertyClearer.getDefaultInstance());

        heightChecker = new ValueHandlerToPropertyAdapter(
                StylePropertyDetails.HEIGHT,
                new PositivePixelLengthOrPercentageHandler(),
                NoopPropertyUpdater.getDefaultInstance());
        heightHandler = new ValueHandlerToPropertyAdapter(
                StylePropertyDetails.HEIGHT,
                new PositivePixelLengthOrPercentageHandler(),
                PropertyClearer.getDefaultInstance());

        mcsRowsHandler = new ValueHandlerToPropertyAdapter(
                StylePropertyDetails.MCS_ROWS, new IntegerHandler());

        mcsColumnsHandler = new ValueHandlerToPropertyAdapter(
                StylePropertyDetails.MCS_COLUMNS, new IntegerHandler());

    }

    // Javadoc inherited.
    protected CSSModule createCSSModule() {
        // Create an instance of CSSModule.
        XHTMLBasicCSSModule cssModule = new XHTMLBasicCSSModule(context);
        
        // Read the target media types out of the protocol configuration.
        ProtocolConfiguration configuration = getProtocolConfiguration();
        
        if (configuration != null) {
            cssModule.setMedia(configuration.getCSSMedia());
        }
        
        return cssModule;
    }

    // ========================================================================
    //   General helper methods.
    // ========================================================================

    /**
     * Add a name attribute with the same value as the id attribute if any.
     * <p>
     * This is needed by some browsers which can only access parts of the
     * document through the name and not the id.
     * </p>
     */
    private void addNameAsId (Element element,
                                MCSAttributes attributes) {

        String value;

        // Add the name attribute to be the same as the id attribute
        // if the protocol does not support targetting elements via their
        // id.
        if (enableNameIdentification && (value = attributes.getId ()) != null) {
            element.setAttribute ("name", value);
        }

    }

    /**
     * Add the attributes that are common across many XHTML elements
     * to the Element.
     * @param element The Element to modify.
     * @param attributes The attributes for the element.
     */
    protected void addCoreAttributes (Element element,
                                      MCSAttributes attributes) {
        addCoreAttributes (element, attributes, true);
    }

    /**
     * Add the attributes that are common across many XHTML elements
     * to the Element.
     * @param element The Element to modify.
     * @param attributes The attributes for the element
     * @param title True if the attributes specify a title, false
     * otherwise.
     */
    protected void addCoreAttributes (Element element,
                                      MCSAttributes attributes,
                                      boolean title) {
        String value;

        if ((value = attributes.getId()) != null) {
            element.setAttribute ("id", value);
        }
        if (title && (value = attributes.getTitle()) != null) {
            element.setAttribute ("title", value);
        }
    }

    /**
     * Set optgroup depth level
     */
    protected void setOptGroupDepth(int depth) {
       maxOptgroupDepth = depth;
    }

    // ==========================================================================
    //   Custom markup methods
    // ==========================================================================

    // javadoc inherited
    public boolean supportsNativeMarkup() {
        return true;
    }

    // ========================================================================
    //   Page element methods
    // ========================================================================

    // Javadoc inherited from super class.
    public String defaultMimeType() {
        return "application/xhtml+xml";
    }

    // javadoc inherited
    public String getPackagingType() {
        return "multipart/mixed";
    }

    /**
     * Allow subclasses to add extra attributes to a body element.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void addBodyAttributes (Element element,
                                      BodyAttributes attributes)
            throws ProtocolException {
    }

    // Javadoc inherited from super class.
    protected void openBody (DOMOutputBuffer dom,
                             BodyAttributes attributes)
            throws ProtocolException {

        Element element = dom.openStyledElement ("body", attributes);

        addCoreAttributes (element, attributes, false);

        addBodyAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected void closeBody (DOMOutputBuffer dom,
                              BodyAttributes attributes) {
        Element bodyElement = dom.closeElement ("body");

        // Process body attributes by the widget module.
        // The Widget.startup() method will registered on load event, if the
        // page includes any widget.
        widgetModule.processBodyElementForStartup(this, bodyElement);
    }

    // Javadoc inherited from super class.
    protected void openCanvas (DOMOutputBuffer dom,
                               CanvasAttributes attributes) {

        Element element = dom.openElement("html");

        if (xmlNamespace != null) {
            element.setAttribute ("xmlns", xmlNamespace);
        }

        // The title is not part of the canvas, it should be written to the
        // head buffer.
        dom = getHeadBuffer ();
        doTitle (dom, attributes);
    }

    // Javadoc inherited from super class.
    protected void closeCanvas (DOMOutputBuffer dom,
                                CanvasAttributes attributes) {
        dom.closeElement("html");
    }

    // Javadoc inherited from super class.
    protected void openHead (DOMOutputBuffer dom,
                             boolean empty) {
        dom.openElement ("head");
    }

    // Javadoc inherited from super class.
    protected void closeHead (DOMOutputBuffer dom,
                              boolean empty) {
        dom.closeElement ("head");
    }

    // Javadoc inherited.
    protected void openInclusion(DOMOutputBuffer dom,
            CanvasAttributes attributes) {

        Element element = dom.openStyledElement("div", attributes);
        addCoreAttributes(element, attributes);
    }

    // Javadoc inherited.
    protected void closeInclusion (DOMOutputBuffer dom,
                                   CanvasAttributes attributes) {

        dom.closeElement("div");
    }

    // Javadoc inherited.
    protected void doProtocolString(Document document) {
        addXHTMLBasicDocType(document);

        addXMLDeclaration(document);
    }

    protected void addXHTMLBasicDocType(Document document) {
        DocType docType = domFactory.createDocType(
                "html", "-//W3C//DTD XHTML Basic 1.0//EN",
                "http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd", null,
                MarkupFamily.XML);
        document.setDocType(docType);
    }

    /**
     * Add the title markup to the specified DOMOutputBuffer.
     * @param dom The DOMOutputBuffer to append to.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void doTitle (DOMOutputBuffer dom,
                            CanvasAttributes attributes) {

        // XHTML protocols require the title element to be present.
        // If the title has not been set then output the empty string
        String value = ((attributes.getPageTitle() == null)
                        ? "" : attributes.getPageTitle());

        dom.openElement ("title");
        dom.appendEncoded (value);
        dom.closeElement ("title");
    }

    // ========================================================================
    //   Dissection methods
    // ========================================================================

    /**
     * Override this method to return an XHTML Basic unabridged transformer
     * which will make sure that the generated markup is valid for XHTML Basic
     * and will utilize rowspan and colspan in table flattening.
     */
    protected DOMTransformer getDOMTransformer() {
        return new XHTMLBasicUnabridgedTransformer(protocolConfiguration);
    }


    // ========================================================================
    //   Layout / format methods
    // ========================================================================

    // javadoc inherited
    protected void openSpatialFormatIterator(DOMOutputBuffer dom,
            SpatialFormatIteratorAttributes attributes) {

        Element element = dom.openStyledElement("table", attributes,
                DisplayKeywords.TABLE);

        addLogicalWidthAttribute(element, attributes);
    }

    /**
     * This method provides a mechanism that allows subclasses of XHTMLBasic to
     * call the original method (openSpatialFormatIterator) in DOMProtocol.
     * <p>
     * For example. XHTMLFull subclasses XHTMLBasic which subclasses
     * DOMProtocol. In order for XHTMLFull to call the original method in
     * DOMProtocol, one simply calls this method from the overridden
     * openSpatialFormatIterator method. This bypasses the implementation for
     * this openSpatialFormatIterator in this class.
     *
     * @param dom        the dom protocol
     * @param attributes the attributes for SpatialFormatIterators
     */
    protected void openSpatialFormatIteratorOriginal(
            DOMOutputBuffer dom,
            SpatialFormatIteratorAttributes attributes) {
        super.openSpatialFormatIterator(dom, attributes);
    }

    /**
     * Append the open pane markup to the specified StringBuffer.
     *
     * @param dom The DOMOutputBuffer to use.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void openPane(DOMOutputBuffer dom,
                            PaneAttributes attributes) {
        // If there is a style attribute for the pane and the device supports
        // style sheets then surround the output with a table/tr/td element.
        if (supportsInlineStyles || supportsExternalStyleSheets) {
            // Write out a table with single row and cell so that the
            // wrapped elements pick up any styles.
            //
            // This table, if found to be nested, will be optimized away by
            // the protocol's associated transformer in such a away as to
            // retain style attributes.
            Element cell;
            Element parent = dom.getCurrentElement();

            Styles tableStyles = attributes.getStyles();

            // A pane is normally treated as a CSS block so now we have to turn
            // it into a table.
            Element table = dom.openStyledElement("table", tableStyles,
                    DisplayKeywords.TABLE);

            addPaneTableAttributes(table, attributes);

            StylingFactory factory = StylingFactory.getDefaultInstance();
            Styles rowStyles = factory.createInheritedStyles(tableStyles,
                    DisplayKeywords.TABLE_ROW);
            dom.openStyledElement("tr", rowStyles);

            Styles cellStyles = factory.createInheritedStyles(rowStyles,
                    DisplayKeywords.TABLE_CELL);
            cell = dom.openStyledElement("td", cellStyles);

            addCoreAttributes(cell, attributes);

            if ((parent != null) && ("td".equals(parent.getName()))) {
                // To ensure that the enclosing cell's attributes, such as
                // align, valign etc., are not lost, copy them down into the
                // new cell, but retaining specifically defined values for
                // this new cell
                cell.mergeAttributes(parent, false);
            }
        }
    }

    /**
     * Add attributes to the table created for the pane.
     *
     * @param element The Element to modify.
     * @param attributes the attributes
     */
    protected void addPaneTableAttributes(Element element,
                                          PaneAttributes attributes) {

        addLogicalWidthAttribute(element, attributes);

    }

    /**
     * Append the close pane markup to the specified StringBuffer.
     *
     * @param dom The DOMOutputBuffer to use.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void closePane(DOMOutputBuffer dom,
                             PaneAttributes attributes) {
        // If a table was generated around the pane, then close it
        if (supportsInlineStyles || supportsExternalStyleSheets) {
            dom.closeElement("td");
            dom.closeElement("tr");
            Element element = dom.closeElement("table");

            // Do any protocol specific work that requires information
            // about the whole of the table.
            postTableConstruction(element);
        }
    }

    /**
     * Called after the table has been constructed and before anything
     * else has been done.
     */
    protected void postTableConstruction(Element element) {
    }

    /**
     * Method to allow subclasses to specify additional attributes for
     * a column iterator pane
     * @param element The Element to modify.
     * @param attributes the attributes
     */
    protected void addColumnIteratorPaneAttributes (Element element,
                                    ColumnIteratorPaneAttributes attributes) {
    }

    // Javadoc inherited from super class.
    protected
        void openColumnIteratorPane (DOMOutputBuffer dom,
                                     ColumnIteratorPaneAttributes attributes) {
        // If there is a style attribute for the pane and the device supports style
        // sheets then surround the output with a div element
        if (supportsInlineStyles || supportsExternalStyleSheets) {
            // write out a div element so that the wrapped elements
            // pick up any needed styles.
            Element element = dom.openStyledElement("div", attributes);
            addCoreAttributes (element, attributes);
        }

        Styles tableStyles = attributes.getStyles();

        // A pane is normally treated as a CSS block so now we have to turn
        // it into a table.
        Element element = dom.openStyledElement ("table", tableStyles,
                DisplayKeywords.TABLE);

        // allow subclasses to supply additional attributes
        addColumnIteratorPaneAttributes (element, attributes);

        StylingFactory factory = StylingFactory.getDefaultInstance();
        Styles rowStyles = factory.createInheritedStyles(tableStyles,
                DisplayKeywords.TABLE_ROW);
        dom.openStyledElement ("tr", rowStyles);
    }

    // Javadoc inherited from super class.
    protected
        void closeColumnIteratorPane (DOMOutputBuffer dom,
                                      ColumnIteratorPaneAttributes attributes) {
        dom.closeElement ("tr");
        Element element = dom.closeElement ("table");
        postTableConstruction(element);

        // If a div tag was generated around the pane, then close it
        // If there is a 'class' attribute for the pane then
        // surround the output with a div element
        if( supportsInlineStyles || supportsExternalStyleSheets )
        {
            dom.closeElement( "div" );
        }
    }

    /**
     * Method to allow subclasses to specify additional attributes for
     * a column iterator pane element
     * @param element The Element to modify.
     * @param attributes the attributes
     */
    protected void addColumnIteratorPaneElementAttributes (Element element,
                                    ColumnIteratorPaneAttributes attributes) {

        addLogicalWidthAttribute(element, attributes);
    }

    // Javadoc inherited from super class.
    protected void openColumnIteratorPaneElement (DOMOutputBuffer dom,
                                    ColumnIteratorPaneAttributes attributes) {

        Element element = dom.openStyledElement ("td", attributes,
                DisplayKeywords.TABLE_CELL);

        // allow subclasses to supply additional attributes
        addColumnIteratorPaneElementAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected void closeColumnIteratorPaneElement
        (DOMOutputBuffer dom, ColumnIteratorPaneAttributes attributes) {

        dom.closeElement ("td");
    }

    /**
     * Does this protocol support Dissection.
     * @return true if and only if the protocol supporst dissection
     */
    public boolean isDissectionSupported() {
        return supportsDissectingPanes;
    }
    /**
     * Open an element whose contents can be split into different shards.
     * @param dom The DOMOutputBuffer to use.
     * @param attributes The attributes used to generate the markup.
     * @todo later check to see if the stylistic div should be output even
     *             when dissection is not supported
     */
    protected
        void openDissectingPane(DOMOutputBuffer dom,
                                DissectingPaneAttributes attributes) {

        if (logger.isDebugEnabled()) {
            logger.debug("Open dissecting pane");
        }

        // Only generate markup if this the protocols supports dissecting panes
        if (supportsDissectingPanes) {
            // If the current device has a maximum page size then we always
            // need to generate markup for a dissecting pane, even if no
            // specific limit was set on the pane itself because we will get a
            // proportion of the available space. If the current device does
            // not have a maximum page size but an explicit limit has been set
            // on this pane then we need to generate markup and remember that
            // we need to dissect the page's contents.
            String value;
            boolean dissectionNeeded = true;
            DissectingPane pane = attributes.getDissectingPane();
            String maxContentSize;

            if (!isDissecting()) {
                if (logger.isDebugEnabled()) {
                    logger.debug("Dissecting not required for total page " +
                                 "size but may be required for this pane");
                }

                if ((maxContentSize = pane.getMaximumContentSize()) == null) {
                    if (logger.isDebugEnabled()) {
                        logger.debug("Dissecting not required for this pane");
                    }

                    dissectionNeeded = false;
                }
            } else {
                if (logger.isDebugEnabled()) {
                    logger.debug("Dissecting required");
                }

                maxContentSize = pane.getMaximumContentSize();
            }

            if (logger.isDebugEnabled()) {
                logger.debug("Maximum content size is set to " +
                             maxContentSize);
            }

            if (dissectionNeeded) {
                // Dissection is needed because we are generating mark up for a
                // dissecting pane.
                setDissectionNeeded(true);

                Element element = dom.openElement(DISSECTABLE_CONTENTS_ELEMENT);
                addCoreAttributes(element, attributes);
                
                Element parent = element.getParent();
                if (parent != null && parent.getStyles() != null) {
                    element.setStyles(StylingFactory.getDefaultInstance()
                            .createInheritedStyles(parent.getStyles(), null));
                    if (logger.isDebugEnabled()) {
                        logger.debug("Setting parent styles");
                    }
                }
                
                if ((value = attributes.getInclusionPath()) != null) {
                    element.setAttribute(INCLUSION_PATH_ATTRIBUTE, value);
                }

                element.setAttribute(DISSECTING_PANE_NAME_ATTRIBUTE,
                                     pane.getName());

//                if ((value = attributes.getStyleClass()) != null) {
//                    element.setAttribute(DISSECTING_PANE_CLASS_ATTRIBUTE,
//                                         value);
//                }

                if ((value = pane.getNextShardShortcut()) != null) {
                    element.setAttribute(NEXT_SHARD_SHORTCUT_ATTRIBUTE,
                                         value);
                }

                if ((value = attributes.getLinkText()) != null) {
                    element.setAttribute(NEXT_SHARD_LINK_TEXT_ATTRIBUTE,
                                         value);
                } else if(( value = pane.getNextShardLinkText()) != null ) {
                    element.setAttribute (NEXT_SHARD_LINK_TEXT_ATTRIBUTE,
                                          value);
                }

                if ((value = pane.getPreviousShardShortcut()) != null) {
                    element.setAttribute(PREVIOUS_SHARD_SHORTCUT_ATTRIBUTE,
                                         value);
                }

                if ((value = attributes.getBackLinkText()) != null) {
                    element.setAttribute(PREVIOUS_SHARD_LINK_TEXT_ATTRIBUTE,
                                         value);
                } else if(( value = pane.getPreviousShardLinkText()) != null ) {
                    element.setAttribute (PREVIOUS_SHARD_LINK_TEXT_ATTRIBUTE, value);
                }

                // set the GENERATE_NEXT_LINK_FIRST_ATTRIBUTE attribute
                // the DissectingPaneAttributes isNextLinkFirst() method
                // returns a boolean so no need for if statement.
                value = String.valueOf(attributes.isNextLinkFirst());
                element.setAttribute (GENERATE_NEXT_LINK_FIRST_ATTRIBUTE,
                                      value);

                if (maxContentSize != null) {
                    element.setAttribute(MAXIMUM_CONTENT_SIZE_ATTRIBUTE,
                                         maxContentSize);
                }
            }

            // If there is a style attribute for the pane and the device
            // supports style sheets then surround the output with a div
            // element
            // @todo later this should, perhaps, always be done irrespective
            //             of support for dissection.
            if (supportsInlineStyles || supportsExternalStyleSheets) {
                // write out a div element so that the wrapped elements
                // pick up any needed styles.
                Element cssElement = dom.openStyledElement("div", attributes);
                addCoreAttributes(cssElement, attributes);
            }
        }
    }

    /**
     * Close an element whose contents can be split into different shards.
     * @param dom The DOMOutputBuffer to use.
     * @param attributes The attributes used to generate the markup.
     * @todo later check to see if the stylistic div should be output even
     *             when dissection is not supported
     */
    protected
        void closeDissectingPane(DOMOutputBuffer dom,
                                 DissectingPaneAttributes attributes) {

        // Only generate markup if this the protocols supports dissecting panes
        if (supportsDissectingPanes) {
            // If a div tag was generated around the pane, then close it
            // @todo later this should, perhaps, always be done irrespective
            //             of support for dissection.
            if (supportsInlineStyles || supportsExternalStyleSheets) {
                dom.closeElement("div");
            }

            // If we didn't generate the open markup then don't try and close
            // it.
            DissectingPane pane = attributes.getDissectingPane();
            boolean dissectionNeeded = true;

            if (!isDissecting()) {
                if (pane.getMaximumContentSize() == null) {
                    dissectionNeeded = false;
                }
            }

            if (dissectionNeeded) {
                dom.closeElement(DISSECTABLE_CONTENTS_ELEMENT);
            }
        }
    }

    // Javadoc inherited from super class.
    protected void openForm (DOMOutputBuffer dom,
                             FormAttributes attributes) {

        // Restore the insertion point back to the saved position before
        // rendering the contents of the form.
        dom.restoreInsertionPoint ();
    }

    /**
     * Method to allow subclasses to specify additional attributes for
     * a grid
     * @param element The Element to modify.
     * @param attributes the attributes
     */
    protected
        void addGridAttributes (Element element,
                                GridAttributes attributes) {

        addLogicalWidthAttribute(element, attributes);
    }

    /**
     * Method to allow subclasses to specify additional row attributes for
     * a grid.
     * @param element The Element to modify.
     * @param attributes the attributes
     */
    private void addGridRowAttributes (Element element,
                                GridRowAttributes attributes) {
    }

    // Javadoc inherited from super class.
    protected void openGrid (DOMOutputBuffer dom,
                             GridAttributes attributes) {

        Element element = dom.openStyledElement ("table", attributes,
                DisplayKeywords.TABLE);

        // Allow subclasses to specify additional attributes
        addGridAttributes(element, attributes);
    }

    // Javadoc inherited from super class.
    protected void closeGrid (DOMOutputBuffer dom,
                              GridAttributes attributes) {

        Element element = dom.closeElement ("table");
        postTableConstruction(element);
    }

    // Javadoc inherited from super class.
    protected void openGridRow (DOMOutputBuffer dom,
                                GridRowAttributes attributes) {

        Element element = dom.openStyledElement ("tr", attributes,
                DisplayKeywords.TABLE_ROW);
        addGridRowAttributes(element, attributes);
    }

    // Javadoc inherited from super class.
    protected void closeGridRow (DOMOutputBuffer dom,
                                 GridRowAttributes attributes) {
        dom.closeElement ("tr");
    }

    /**
     * Method to allow subclasses to specify additional attributes for
     * a grid children
     * @param element The Element to modify.
     * @param attributes the attributes
     */
    protected
        void addGridChildAttributes (Element element,
                                     GridChildAttributes attributes) {
    }

    // Javadoc inherited from super class.
    protected void openGridChild (DOMOutputBuffer dom,
                                  GridChildAttributes attributes) {

        Styles styles = attributes.getStyles();
        String value;

        Element element = dom.openStyledElement ("td", attributes,
                DisplayKeywords.TABLE_CELL);

        // Render the various attributes into a StringBuffer

        if ((value = horizontalAlignHandler.getAsString(styles)) != null) {
            element.setAttribute ("align", value);
        }
        if ((value = verticalAlignHandler.getAsString(styles)) != null) {
            element.setAttribute ("valign", value);
        }

        // allow subclasses to specify additional attributes.
        addGridChildAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected void closeGridChild (DOMOutputBuffer dom,
                                   GridChildAttributes attributes) {
        dom.closeElement ("td");
    }


    // Javadoc inherited from super class.
    protected
        void openRowIteratorPane (DOMOutputBuffer dom,
                                  RowIteratorPaneAttributes attributes) {

        // Add a line break at the start of the row iterator pane to separate
        // the content from any previous mark up. If the previous mark up was
        // the end (or beginning of a block element) then we could end up with
        // too much white space. Fixing this requires that we check the
        // previous element and only add the break if we need to but that is
        // not that easy to do so we will leave it for now.
        dom.addStyledElement ("br", attributes);

        // If there is a style attribute for the pane and the device supports style
        // sheets then surround the output with a div element
        if (supportsInlineStyles || supportsExternalStyleSheets) {
            // write out a div element so that the wrapped elements
            // pick up any needed styles.
            Element element = dom.openStyledElement("div", attributes);
            addCoreAttributes (element, attributes);
        }
    }

    // Javadoc inherited from super class.
    protected
        void closeRowIteratorPane (DOMOutputBuffer dom,
                                   RowIteratorPaneAttributes attributes) {
        // If a div tag was generated around the pane, then close it
        // If there is a 'class' attribute for the pane then
        // surround the output with a div element
        if( supportsInlineStyles || supportsExternalStyleSheets ) {
            dom.closeElement( "div" );
        }
    }

    // Javadoc inherited from super class.
    protected
        void openRowIteratorPaneElement (DOMOutputBuffer dom,
                                         RowIteratorPaneAttributes attributes) {
    }

    // Javadoc inherited from super class.
    protected
        void closeRowIteratorPaneElement (DOMOutputBuffer dom,
                                          RowIteratorPaneAttributes attributes) {
        // Add a line break after each element in the row.
        dom.addStyledElement ("br", attributes);
    }

    /**
     * Add a "logical" width attribute which will be transformed as necessary
     * into the form required for emulation purposes by
     * {@link TableWidthTransformer}.
     *
     * @param element the element to add a width attribute to.
     * @param attributes the attributes which contain width information.
     */
    private void addLogicalWidthAttribute(Element element,
            MCSAttributes attributes) {

        // Do any XHTMLBasic width emulation. This is overridden by XHTMLFull
        // which does it's own which is much more complex.

        InternalDevice device = context.getDevice();

        String emulateWidth = device.getPolicyValue(
                DevicePolicyConstants.PROTOCOL_CSS_EMULATE_WIDTH_TABLE);

        if (emulateWidth == null || emulateWidth.equals(
                DevicePolicyConstants.PROTOCOL_CSS_EMULATE_WIDTH_TABLE__NONE)) {
            // No emulation, do nothing.

        } else if (emulateWidth.equals(
                        DevicePolicyConstants.PROTOCOL_CSS_EMULATE_WIDTH_TABLE__WIDTH_ATTRIBUTE) ||
                emulateWidth.equals(
                        DevicePolicyConstants.PROTOCOL_CSS_EMULATE_WIDTH_TABLE__STYLE_ATTRIBUTE)) {

            // Emulate using a "logical" width attribute. This will be
            // translated into an actual attribute by the transformer.

            final Styles styles = attributes.getStyles();

            PropertyHandler widthHandler = getCorrectWidthHandler(element);
            final boolean significant =
                    widthHandler.isSignificant(styles);
            String value;
            if ((value = widthHandler.getAsString(styles)) != null) {
                if (significant) {
                    element.setAttribute("width", value);
                } else {
                    // throw away the value otherwise it stays in the theme
                    // and will be used by CSS aware browsers to override
                    // any value we already rendered on the element
                }
            }

        } else {
            // Generate a warning since the value is unknown.
            // todo:
        }
    }

    // ========================================================================
    //   Navigation methods.
    // ========================================================================

    protected void addAnchorAttributes (Element element,
                                        AnchorAttributes attributes)
            throws ProtocolException {
    }

    // JavaDoc inherited
    public void openAnchor(DOMOutputBuffer dom, AnchorAttributes attributes)
            throws ProtocolException {

        String value;

        Element element = dom.openStyledElement ("a", attributes);

        addCoreAttributes (element, attributes);

        LinkAssetReference reference = attributes.getHref();
        if (reference != null) {
            element.setAttribute ("href", reference.getURL());
        }
        if (supportsAccessKeyAttribute
            && (value = getPlainText (attributes.getShortcut())) != null) {
            element.setAttribute ("accesskey", value);
        }
        String tabindex = attributes.getTabindex();
        if (supportsTabindex && tabindex != null) {
            element.setAttribute ("tabindex", tabindex);
        }

        // Emulate name using id if required.
        addNameAsId(element, attributes);

        // Allow subclasses to add extra attributes to the anchor.
        addAnchorAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    public void closeAnchor(DOMOutputBuffer dom, AnchorAttributes attributes) {
        dom.closeElement ("a");
    }

    // Javadoc inherited from super class.
    protected void doDefaultSegmentLink (DOMOutputBuffer dom,
                                         AnchorAttributes attributes)
            throws ProtocolException {

        attributes.setContent ("Back");

        doAnchor (dom, attributes);
    }

    /**
     * Generate the markup for a shard link.
     * @param dom The DOMOutputBuffer to add the markup to.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void doShardLink(DOMOutputBuffer dom,
                               ShardLinkAttributes attributes)
            throws ProtocolException {

        AnchorAttributes a = new AnchorAttributes();

        // Initialise the anchor attributes.
        a.copy(attributes);

        a.setShortcut(new LiteralTextAssetReference(attributes.getShortcut()));
        a.setContent(attributes.getLinkText());
        a.setHref(attributes.getHref());

        doAnchor(dom, a);
    }

    /**
     * Provided to allow specializations to add extra attributes to the
     * phone number (anchor) element given.
     *
     * @param element the (anchor) element representing the phone number
     * @param attributes the attributes defined for the phone number
     */
    protected void addPhoneNumberAttributes(Element element,
                                            PhoneNumberAttributes attributes) throws ProtocolException {
    }

    /**
     * A phone number is created using an anchor element. The href is
     * automatically defined to be the qualified full number. Other
     * attributes can be defined using {@link #addPhoneNumberAttributes}.
     */
    protected void openPhoneNumber(DOMOutputBuffer dom,
                                   PhoneNumberAttributes attributes)
            throws ProtocolException {
        String value;
        Element element = dom.openStyledElement("a", attributes);

        addCoreAttributes(element, attributes);

        element.setAttribute("href", attributes.getQualifiedFullNumber());

        if (supportsAccessKeyAttribute &&
            (value = getPlainText(attributes.getShortcut())) != null) {
            element.setAttribute("accesskey", value);
        }

        if (supportsTabindex &&
            (value = attributes.getTabindex()) != null) {
            element.setAttribute("tabindex", value);
        }

        addPhoneNumberAttributes(element, attributes);
    }

    /**
     * Closes the element openned in {@link #openPhoneNumber}.
     */
    protected void closePhoneNumber(DOMOutputBuffer dom,
                                    PhoneNumberAttributes attributes) {
        dom.closeElement("a");
    }

    // ========================================================================
    //   Block element methods.
    // ========================================================================

    /**
     * Allow subclasses to add extra attributes.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void addAddressAttributes (Element element,
                                         AddressAttributes attributes)
            throws ProtocolException {
    }

    // Javadoc inherited from super class.
    protected void openAddress (DOMOutputBuffer dom,
                                AddressAttributes attributes)
            throws ProtocolException {

        Element element = dom.openStyledElement ("address", attributes);

        addCoreAttributes (element, attributes);

        addAddressAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected void closeAddress (DOMOutputBuffer dom,
                                 AddressAttributes attributes) {
        dom.closeElement ("address");
    }

    /**
     * Allow subclasses to add extra attributes.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void addBlockQuoteAttributes (Element element,
                                            BlockQuoteAttributes attributes)
            throws ProtocolException {
    }

    // Javadoc inherited from super class.
    protected void openBlockQuote (DOMOutputBuffer dom,
                                   BlockQuoteAttributes attributes)
            throws ProtocolException {

        String value;

        Element element = dom.openStyledElement ("blockquote", attributes);

        addCoreAttributes (element, attributes);

        if ((value = attributes.getCite ()) != null) {
            element.setAttribute ("cite", value);
        }

        addBlockQuoteAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected void closeBlockQuote (DOMOutputBuffer dom,
                                    BlockQuoteAttributes attributes) {
        dom.closeElement ("blockquote");
    }

    /**
     * Method to allow subclasses to specify additional attributes for
     * The Div element
     * @param element The Element to modify.
     * @param attributes the attributes
     */
    protected void addDivAttributes (Element element,
                                     DivAttributes attributes)
            throws ProtocolException {
    }

    // Javadoc inherited from super class.
    public void openDiv (DOMOutputBuffer dom,
                            DivAttributes attributes)
            throws ProtocolException {

        if ("true".equals(attributes.getKeepTogether())) {
          dom.openElement(KEEPTOGETHER_ELEMENT);
        }
        Element element = dom.openStyledElement ("div", attributes);

        addCoreAttributes (element, attributes);

        // allow subclasses to insert additional attributes
        addDivAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    public void closeDiv (DOMOutputBuffer dom,
                             DivAttributes attributes) {
        dom.closeElement ("div");
        if ("true".equals(attributes.getKeepTogether())) {
          dom.closeElement(KEEPTOGETHER_ELEMENT);
        }
    }

    /**
     * Allow subclasses to add extra attributes to a heading.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup
     * @param level The level of the heading.
     */
    protected void addHeadingAttributes (Element element,
                                         HeadingAttributes attributes,
                                         int level) throws ProtocolException {
    }

    /**
     * Generate open heading markup at the specified level.
     * @param dom The DOMOutputBuffer to use.
     * @param attributes The attributes to use when generating the markup.
     * @param level The level of the heading.
     */
    private void openHeading (DOMOutputBuffer dom,
                                HeadingAttributes attributes,
                                int level) throws ProtocolException {

        String elementName = headingElementNames [level];

        Element element = dom.openStyledElement (elementName, attributes);

        addCoreAttributes (element, attributes);

        addHeadingAttributes (element, attributes, level);
    }

    /**
     * Generate close heading markup at the specified level.
     * @param dom The DOMOutputBuffer to use.
     * @param attributes The attributes to use when generating the markup.
     * @param level The level of the heading.
     */
    private void closeHeading (DOMOutputBuffer dom,
                                 HeadingAttributes attributes,
                                 int level) {

        String elementName = headingElementNames [level];

        dom.closeElement (elementName);
    }

    // Javadoc inherited from super class.
    protected void openHeading1 (DOMOutputBuffer dom,
                                 HeadingAttributes attributes)
            throws ProtocolException {

        openHeading (dom, attributes, 1);
    }

    // Javadoc inherited from super class.
    protected void closeHeading1 (DOMOutputBuffer dom,
                                  HeadingAttributes attributes) {

        closeHeading (dom, attributes, 1);
    }

    // Javadoc inherited from super class.
    protected void openHeading2 (DOMOutputBuffer dom,
                                 HeadingAttributes attributes)
            throws ProtocolException {

        openHeading (dom, attributes, 2);
    }

    // Javadoc inherited from super class.
    protected void closeHeading2 (DOMOutputBuffer dom,
                                  HeadingAttributes attributes) {

        closeHeading (dom, attributes, 2);
    }

    // Javadoc inherited from super class.
    protected void openHeading3 (DOMOutputBuffer dom,
                                 HeadingAttributes attributes)
            throws ProtocolException {

        openHeading (dom, attributes, 3);
    }

    // Javadoc inherited from super class.
    protected void closeHeading3 (DOMOutputBuffer dom,
                                  HeadingAttributes attributes) {

        closeHeading (dom, attributes, 3);
    }

    // Javadoc inherited from super class.
    protected void openHeading4 (DOMOutputBuffer dom,
                                 HeadingAttributes attributes)
            throws ProtocolException {

        openHeading (dom, attributes, 4);
    }

    // Javadoc inherited from super class.
    protected void closeHeading4 (DOMOutputBuffer dom,
                                  HeadingAttributes attributes) {

        closeHeading (dom, attributes, 4);
    }

    // Javadoc inherited from super class.
    protected void openHeading5 (DOMOutputBuffer dom,
                                 HeadingAttributes attributes)
            throws ProtocolException {

        openHeading (dom, attributes, 5);
    }

    // Javadoc inherited from super class.
    protected void closeHeading5 (DOMOutputBuffer dom,
                                  HeadingAttributes attributes) {

        closeHeading (dom, attributes, 5);
    }

    // Javadoc inherited from super class.
    protected void openHeading6 (DOMOutputBuffer dom,
                                 HeadingAttributes attributes)
            throws ProtocolException {

        openHeading (dom, attributes, 6);
    }

    // Javadoc inherited from super class.
    protected void closeHeading6 (DOMOutputBuffer dom,
                                  HeadingAttributes attributes) {

        closeHeading (dom, attributes, 6);
    }

    /**
     * Allow subclasses to add extra attributes to a paragraph.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void addParagraphAttributes (Element element,
                                           ParagraphAttributes attributes)
            throws ProtocolException {
    }

    // Javadoc inherited from super class.
    protected void openParagraph (DOMOutputBuffer dom,
                                  ParagraphAttributes attributes)
            throws ProtocolException {

        Element element = dom.openStyledElement ("p", attributes);

        addCoreAttributes (element, attributes);

        addParagraphAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected void closeParagraph (DOMOutputBuffer dom,
                                   ParagraphAttributes attributes) {
        dom.closeElement ("p");
    }

    /**
     * Method to allow subclasses to specify additional attributes for
     * the Pre element
     * @param element The Element to modify.
     * @param attributes the attributes
     */
    protected void addPreAttributes (Element element,
                                     PreAttributes attributes)
            throws ProtocolException {
    }

    // Javadoc inherited from super class.
    protected void openPre (DOMOutputBuffer dom,
                            PreAttributes attributes)
            throws ProtocolException {

        Element element = dom.openStyledElement ("pre", attributes);

        addCoreAttributes (element, attributes);

        // Allow subclasses to add extra attributes to pre.
        addPreAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected void closePre (DOMOutputBuffer dom,
                             PreAttributes attributes) {
        dom.closeElement ("pre");
    }

    // ========================================================================
    //   List element methods.
    // ========================================================================

    /**
     * Allow subclasses to add extra attributes.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void addDefinitionListAttributes (Element element,
            DefinitionListAttributes attributes) throws ProtocolException {
    }

    // Javadoc inherited from super class.
    protected
        void openDefinitionList (DOMOutputBuffer dom,
                                 DefinitionListAttributes attributes)
            throws ProtocolException {

        Element element = dom.openStyledElement ("dl", attributes);

        addCoreAttributes (element, attributes);

        addDefinitionListAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected
        void closeDefinitionList (DOMOutputBuffer dom,
                                  DefinitionListAttributes attributes) {
        dom.closeElement ("dl");
    }

    /**
     * Allow subclasses to add extra attributes.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void addDefinitionTermAttributes (Element element,
            DefinitionTermAttributes attributes) throws ProtocolException {
    }

    // Javadoc inherited from super class.
    protected
        void openDefinitionTerm (DOMOutputBuffer dom,
                                 DefinitionTermAttributes attributes)
            throws ProtocolException {

        Element element = dom.openStyledElement ("dt", attributes);

        addCoreAttributes (element, attributes);

        addDefinitionTermAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected
        void closeDefinitionTerm (DOMOutputBuffer dom,
                                  DefinitionTermAttributes attributes) {
        dom.closeElement ("dt");
    }

    /**
     * Allow subclasses to add extra attributes.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void addDefinitionDataAttributes (Element element,
            DefinitionDataAttributes attributes) throws ProtocolException {
    }

    // Javadoc inherited from super class.
    protected
        void openDefinitionData (DOMOutputBuffer dom,
                                 DefinitionDataAttributes attributes)
            throws ProtocolException {

        Element element = dom.openStyledElement ("dd", attributes);

        addCoreAttributes (element, attributes);

        addDefinitionDataAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected
        void closeDefinitionData (DOMOutputBuffer dom,
                                  DefinitionDataAttributes attributes) {
        dom.closeElement ("dd");
    }

    /**
     * Method to allow subclasses to specify additional attributes for
     * Ordered Lists
     * @param element The Element to modify.
     * @param attributes the attributes
     */
    protected
        void addOrderedListAttributes (Element element,
                                       OrderedListAttributes attributes)
            throws ProtocolException {
    }

    // Javadoc inherited from super class.
    protected void openOrderedList (DOMOutputBuffer dom,
                                    OrderedListAttributes attributes)
            throws ProtocolException {

        Element element = dom.openStyledElement ("ol", attributes);

        addCoreAttributes (element, attributes);

        // Allow subclasses to add extra attributes.
        addOrderedListAttributes (element, attributes);

        // No more attributes, close the tag and return the string
    }

    // Javadoc inherited from super class.
    protected void closeOrderedList (DOMOutputBuffer dom,
                                     OrderedListAttributes attributes) {
        dom.closeElement ("ol");
    }

    /**
     * Method to allow subclasses to specify additional attributes for
     * unordered lists
     * @param element The Element to modify.
     * @param attributes the attributes
     */
    protected
        void addUnorderedListAttributes (Element element,
                                         UnorderedListAttributes attributes)
            throws ProtocolException {
    }

    // Javadoc inherited from super class.
    protected
        void openUnorderedList (DOMOutputBuffer dom,
                                UnorderedListAttributes attributes)
            throws ProtocolException {

        Element element = dom.openStyledElement ("ul", attributes);

        addCoreAttributes (element, attributes);

        // Allow subclasses to add extra attributes.
        addUnorderedListAttributes (element, attributes);

        // No more attributes, close the tag and return the string
    }

    // Javadoc inherited from super class.
    protected
        void closeUnorderedList (DOMOutputBuffer dom,
                                 UnorderedListAttributes attributes) {
        dom.closeElement ("ul");
    }

    /**
     * Method to allow subclasses to specify additional attributes for
     * Lists Items. By default we copy an optional href attribute.
     * This is used by XHTML2 li elements.
     *
     * @param element The Element to modify.
     * @param attributes the attributes
     */
    protected void addListItemAttributes(Element element,
                                         ListItemAttributes attributes)
        throws ProtocolException {

        LinkAssetReference url = attributes.getHref();
        if (url != null && url.getURL() != null) {
            element.setAttribute("href", url.getURL());
        }
    }

    // Javadoc inherited from super class.
    protected void openListItem (DOMOutputBuffer dom,
                                 ListItemAttributes attributes)
            throws ProtocolException {

        Element element = dom.openStyledElement ("li", attributes);

        addCoreAttributes (element, attributes);

        // Allow subclasses to add extra attributes to the list item.
        addListItemAttributes (element, attributes);

        // No more attributes, close the tag and return the string
    }

    // Javadoc inherited from super class.
    protected void closeListItem (DOMOutputBuffer dom,
                                  ListItemAttributes attributes) {
        dom.closeElement ("li");
    }

    // ========================================================================
    //   Table element methods.
    // ========================================================================

    /**
     * Method to allow subclasses to specify additional attributes for
     * the table element
     * @param element The Element to modify.
     * @param attributes the attributes
     */
    protected void addTableAttributes (Element element,
                                       TableAttributes attributes)
            throws ProtocolException {
    }

    // Javadoc inherited from super class.
    protected void openTable (DOMOutputBuffer dom,
                              TableAttributes attributes)
            throws ProtocolException {

        // Normally we could let the display be the same as the input since
        // the input and output elements match but that breaks mozilla which
        // always expects display:table for a table so let's just fix it to
        // that for now. Users setting the display of table elements doesn't
        // make a lot of sense anyway so I can't see much of a problem with
        // this.
        Element element = dom.openStyledElement ("table", attributes,
                DisplayKeywords.TABLE);

        addCoreAttributes (element, attributes);

        // allow subclasses to add additional attributes
        addTableAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected void closeTable (DOMOutputBuffer dom,
                               TableAttributes attributes) {

        dom.closeElement ("table");
    }

    /**
     * Add deprecated stylistic attrubutes that remain on the tag of
     * table cell type tags.
     * @param element The Element to modify.
     * @param attributes <code>TableCellAttributes</code> to add to the tag
     */
    protected void addTableCellAttributes (Element element,
                                           TableCellAttributes attributes)
            throws ProtocolException {

        Styles styles = attributes.getStyles();
        String value = null;
        if ((value = attributes.getColSpan ()) != null) {
            element.setAttribute ("colspan", value);
        }
        if ((value = attributes.getRowSpan ()) != null) {
            element.setAttribute ("rowspan", value);
        }
        if ((value = horizontalAlignHandler.getAsString(styles)) != null) {
            element.setAttribute ("align", value);
        }
        if ((value = verticalAlignHandler.getAsString(styles)) != null) {
            element.setAttribute ("valign", value);
        }
    }

    // Javadoc inherited from super class.
    protected
        void openTableDataCell (DOMOutputBuffer dom,
                                TableCellAttributes attributes)
            throws ProtocolException {

        Element element = dom.openStyledElement ("td", attributes,
                DisplayKeywords.TABLE_CELL);

        addCoreAttributes (element, attributes);

        addTableCellAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected
        void closeTableDataCell (DOMOutputBuffer dom,
                                 TableCellAttributes attributes) {

        dom.closeElement ("td");
    }

    // Javadoc inherited from super class.
    protected
        void openTableHeaderCell (DOMOutputBuffer dom,
                                  TableCellAttributes attributes)
            throws ProtocolException {

        Element element = dom.openStyledElement ("th", attributes,
                DisplayKeywords.TABLE_CELL);

        addCoreAttributes (element, attributes);

        addTableCellAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected
        void closeTableHeaderCell (DOMOutputBuffer dom,
                                   TableCellAttributes attributes) {
        dom.closeElement ("th");
    }

    protected void addTableRowAttributes (Element element,
                                          TableRowAttributes attributes)
            throws ProtocolException {
    }

    // Javadoc inherited from super class.
    protected void openTableRow (DOMOutputBuffer dom,
                                 TableRowAttributes attributes)
            throws ProtocolException {

        Styles styles = attributes.getStyles();
        String value;

        Element element = dom.openStyledElement ("tr", attributes,
                DisplayKeywords.TABLE_ROW);

        addCoreAttributes (element, attributes);

        if ((value = horizontalAlignHandler.getAsString(styles)) != null) {
            element.setAttribute ("align", value);
        }
        if ((value = verticalAlignHandler.getAsString(styles)) != null) {
            element.setAttribute ("valign", value);
        }

        // Allow subclasses to add extra attributes to the table row.
        addTableRowAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected void closeTableRow (DOMOutputBuffer dom,
                                  TableRowAttributes attributes) {
        dom.closeElement ("tr");
    }

    // Javadoc inherited from super class.
    protected void closeTableCaption(DOMOutputBuffer dom,
                                     CaptionAttributes attributes) {
        dom.closeElement("caption");
    }

    // Javadoc inherited from super class.
    protected void openTableCaption(DOMOutputBuffer dom,
                                    CaptionAttributes attributes)
        throws ProtocolException {
        Element element = dom.openStyledElement ("caption", attributes);
        addCoreAttributes (element, attributes);
    }

    // ========================================================================
    //   Inline element methods.
    // ========================================================================

    /**
     * Returns true if the element is an inline constant (as defined in
     * {@link HTMLConstants}) or an element that can be an inline constant
     * if its parent is.
     *
     * @param tagName   name of the element
     * @return true if the element is an inline constant, false otherwise
     */
    public boolean isInlineElement(String tagName) {
        for (int i = 0; i < HTMLConstants.INLINE_ELEMENTS.length; i++) {
            if (HTMLConstants.INLINE_ELEMENTS[i].equalsIgnoreCase(tagName)) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Checks if the element is a valid form parent
     * 
     * @param tagName name of the element
     * @return true if element is a valid form parent, false otherwise
     */
    public boolean isValidFormParent(String tagName) {
        boolean isValid = (tagName != null);
        for (int i = 0; isValid && i < invalidFormParents.size(); i++) {
            isValid = !tagName.equalsIgnoreCase((String) invalidFormParents
                    .get(i));
        }
        return isValid;
    }

    /**
     * Allow subclasses to add extra attributes.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void addCiteAttributes (Element element,
                                      CiteAttributes attributes)
            throws ProtocolException {
    }

    // Javadoc inherited from super class.
    protected void openCite (DOMOutputBuffer dom,
                             CiteAttributes attributes)
            throws ProtocolException {

        Element element = dom.openStyledElement ("cite", attributes);

        addCoreAttributes (element, attributes);

        addCiteAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected void closeCite (DOMOutputBuffer dom,
                              CiteAttributes attributes) {

        dom.closeElement ("cite");
    }

    /**
     * Allow subclasses to add extra attributes.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void addCodeAttributes (Element element,
                                      CodeAttributes attributes)
            throws ProtocolException {
    }

    // Javadoc inherited from super class.
    protected void openCode (DOMOutputBuffer dom,
                             CodeAttributes attributes)
            throws ProtocolException {

        Element element = dom.openStyledElement ("code", attributes);

        addCoreAttributes (element, attributes);

        addCodeAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected void closeCode (DOMOutputBuffer dom,
                              CodeAttributes attributes) {

        dom.closeElement ("code");
    }

    /**
     * Allow subclasses to add extra attributes.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void addEmphasisAttributes (Element element,
                                          EmphasisAttributes attributes)
            throws ProtocolException {
    }

    // Javadoc inherited from super class.
    protected void openEmphasis (DOMOutputBuffer dom,
                                 EmphasisAttributes attributes)
            throws ProtocolException {

        Element element = dom.openStyledElement ("em", attributes);

        addCoreAttributes (element, attributes);

        addEmphasisAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected void closeEmphasis (DOMOutputBuffer dom,
                                  EmphasisAttributes attributes) {

        dom.closeElement ("em");
    }

    /**
     * Allow subclasses to add extra attributes.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void addKeyboardAttributes (Element element,
                                          KeyboardAttributes attributes)
            throws ProtocolException {
    }

    // Javadoc inherited from super class.
    protected void openKeyboard (DOMOutputBuffer dom,
                                 KeyboardAttributes attributes)
            throws ProtocolException {

        Element element = dom.openStyledElement ("kbd", attributes);

        addCoreAttributes (element, attributes);

        addKeyboardAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected void closeKeyboard (DOMOutputBuffer dom,
                                  KeyboardAttributes attributes) {

        dom.closeElement ("kbd");
    }

    /**
     * Add the linebreak attributes appropriate to the protocol.
     * @param element The Element to modify
     * @param attributes The attributes to use when generating the markup.
     */
    protected void addLineBreakAttributes(Element element,
                                          LineBreakAttributes attributes) {
    }

    // Javadoc inherited from super class.
    protected void doLineBreak (DOMOutputBuffer dom,
                                LineBreakAttributes attributes) {

        Element element = dom.addStyledElement ("br", attributes);

        addCoreAttributes (element, attributes);
        addLineBreakAttributes(element, attributes);
    }

    /**
     * Allow subclasses to add extra attributes.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void addHorizontalRuleAttributes (Element element,
            HorizontalRuleAttributes attributes)
    throws ProtocolException {
    }

    // Javadoc Inherited
    protected void doHorizontalRule(DOMOutputBuffer dom,
            HorizontalRuleAttributes attributes) throws ProtocolException {

        InternalDevice device = getMarinerPageContext().getDevice();
        HorizontalRuleEmulator hrEmulator =
                    HorizontalRuleEmulatorFactory.getInstance()
                            .getEmulator(device, attributes, this.supportsCSS);

        Element element = null;
        if (hrEmulator != null) {
            element = hrEmulator.emulateHorizontalRule(dom, attributes);
        } else {
            element = dom.addStyledElement ("hr", attributes);
        }

        if (element != null) {
            addCoreAttributes (element, attributes);
            addHorizontalRuleAttributes( element, attributes );
            addGeneralEventAttributes (element, attributes);
        }
    }


    /**
     * Allow subclasses to add extra attributes.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void addSampleAttributes (Element element,
                                        SampleAttributes attributes)
            throws ProtocolException {
    }

    // Javadoc inherited from super class.
    protected void openSample (DOMOutputBuffer dom,
                               SampleAttributes attributes)
            throws ProtocolException {

        Element element = dom.openStyledElement ("samp", attributes);

        addCoreAttributes (element, attributes);

        addSampleAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected void closeSample (DOMOutputBuffer dom,
                                SampleAttributes attributes) {

        dom.closeElement ("samp");
    }

    /**
     * Allow subclasses to add extra attributes.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void addSpanAttributes (Element element,
                                      SpanAttributes attributes)
            throws ProtocolException {
    }

    // JavaDoc inherited
    public void openSpan(DOMOutputBuffer dom, SpanAttributes attributes)
            throws ProtocolException {
        Element element = dom.openStyledElement ("span", attributes);
        addCoreAttributes (element, attributes);
        addSpanAttributes (element, attributes);
    }

    // JavaDoc inherited
    public void closeSpan(DOMOutputBuffer dom, SpanAttributes attributes) {
        dom.closeElement ("span");
    }

    /**
     * Allow subclasses to add extra attributes.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void addStrongAttributes (Element element,
                                        StrongAttributes attributes)
            throws ProtocolException {
    }

    // Javadoc inherited from super class.
    protected void openStrong (DOMOutputBuffer dom,
                               StrongAttributes attributes)
            throws ProtocolException {

        Element element = dom.openStyledElement ("strong", attributes);

        addCoreAttributes (element, attributes);

        addStrongAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected void closeStrong (DOMOutputBuffer dom,
                                StrongAttributes attributes) {

        dom.closeElement ("strong");
    }

    // ========================================================================
    //   Special element methods.
    // ========================================================================

    /**
     * Method to allow subclasses to specify additional attributes for
     * the image element
     * @param element The Element to modify.
     * @param attributes the attributes
     */
    protected void addImageAttributes (Element element,
                                       ImageAttributes attributes)
            throws ProtocolException {
    }

    /**
     * Helper method which sets the image src on the element. It can be overridden by
     * subclasses which need to set other attributes in relation to the src.
     * @param element The element to set the src on
     * @param attributes The attributes which contain the src
     */
    private void setImageSrc(Element element,
                               ImageAttributes attributes) {

        // here is where we do all the image src stuff
        String value = attributes.getSrc();
        if (attributes.getAssetURLSuffix() != null) {
            value = value + attributes.getAssetURLSuffix();
        }

        if (supportsLocalSourceImg && attributes.isLocalSrc()) {
            element.setAttribute("localsrc", value);
            element.setAttribute("src", "");
        } else {
            element.setAttribute("src", value);
        }
    }

    // Javadoc inherited from super class.
    protected void doImage (DOMOutputBuffer dom,
                            ImageAttributes attributes)
            throws ProtocolException {
      String value = attributes.getSrc();

      String altText = null;

      if (context != null) {
          TextAssetReference reference = attributes.getAltText();
          altText = getPlainText(reference);
      }

      if (value != null) {
        Element element = dom.addStyledElement ("img", attributes);

        addCoreAttributes (element, attributes);
        setImageSrc(element, attributes);

        if ((altText == null) && altTextForImgRequired) {
            // set the alt text to the empty string
            altText = "";
        }

        if (altText != null) {
            element.setAttribute("alt", altText);
        }

        if ((value = attributes.getWidth()) != null) {
            element.setAttribute ("width", value);
        }

        if ((value = attributes.getHeight()) != null) {
            element.setAttribute ("height", value);
        }

        // Emulate name using id if required.
        addNameAsId(element, attributes);

        // Allow subclasses to add extra attributes to the image.
        addImageAttributes (element, attributes);

      } else if (altText != null) {
        if (!WhitespaceUtilities.isWhitespace(altText,0,altText.length())) {
            SpanAttributes sa = new SpanAttributes();
            sa.setId(attributes.getId());
            sa.setStyles(attributes.getStyles());

            openSpan(dom, sa);
            dom.appendEncoded(altText);
            closeSpan(dom, sa);
        }
      }
    }

    // Javadoc inherited
    protected final void doObject(DOMOutputBuffer dom,
            ObjectAttribute attributes,
            DOMOutputBuffer content) {        
        
        // Open object element.
        Element element = dom.openStyledElement("object", attributes);
        
        addCoreAttributes(element, attributes);
        
        // Fill object element attributes.
        if (attributes.getSrc() != null) {
            element.setAttribute("data", attributes.getSrc());
        }
        
        if (attributes.getSrcType() != null) {
            element.setAttribute("type", attributes.getSrcType());
        }
        
        // Add parameters to DOM buffer. 
        Iterator iterator = attributes.getParamMap().entrySet().iterator();
        
        while (iterator.hasNext()) {
            Map.Entry entry = (Map.Entry) iterator.next();
            
            String name = (String) entry.getKey();
            String value = (String) entry.getValue();
            
            Element param = dom.addElement("param");
            
            param.setAttribute("name", name);
            param.setAttribute("value", value);
        }
        
        // Add object element content.
        dom.transferContentsFrom(content);
        
        // Close object element.
        dom.closeElement("object");
    }

    // ========================================================================
    //   Menu element methods.
    // ========================================================================

    // Javadoc inherited from super class.
    protected void addVerticalMenuItemSeparator (DOMOutputBuffer dom) {
        dom.addElement ("br");
    }

    // Javadoc inherited from super class.
    protected void addHorizontalMenuItemSeparator (DOMOutputBuffer dom) {
        dom.appendEncoded(NBSP);
    }

    /**
     * Allow subclasses to add extra attributes.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     * @param type The type of the menu items being added, must be one of
     * ROLLOVER_IMAGE_MENU_ITEM, ROLLOVER_TEXT_MENU_ITEM, PLAIN_MENU_ITEM.
     */
    protected void addMenuItemAttributes (Element element,
                                          MenuItem attributes,
                                          int type)
            throws ProtocolException {
    }

    /**
     * Open an anchor element for the menu item.
     * @param dom The DOMOutputBuffer to use.
     * @param item the MenuItem
     * @param resolvedHref the href of the menu item
     * @param type The type of the menu items being added, must be one of
     * ROLLOVER_IMAGE_MENU_ITEM, ROLLOVER_TEXT_MENU_ITEM, PLAIN_MENU_ITEM.
     * @return The Element created.
     */
    protected Element openMenuItemAnchor (DOMOutputBuffer dom,
                                          MenuItem item,
                                          String resolvedHref,
                                          int type)
            throws ProtocolException {

        return openMenuItemAnchor(dom, item, null, resolvedHref, type);
    }

    /**
     * Open a menu.
     * @param dom The DOMOutputBuffer to write to.
     * @param attributes The MenuAttributes for the menu.
     */
    protected void openMenu(DOMOutputBuffer dom, MenuAttributes attributes) {
        Element element = dom.openStyledElement("div", attributes);
        addCoreAttributes(element, attributes);
    }

    /**
     * Close a menu.
     * @param dom The DOMOutputBuffer to write to.
     * @param attributes The MenuAttributes for the menu.
     */
    protected void closeMenu(DOMOutputBuffer dom, MenuAttributes attributes) {
        dom.closeElement("div");
    }

    /**
     * Open an anchor element for the menu item.
     * @param dom The DOMOutputBuffer to use.
     * @param item the MenuItem
     * @param attributes The MenuAttributes of the menu that the menu item
     * belongs to - can be null.
     * @param resolvedHref the href of the menu item
     * @param type The type of the menu items being added, must be one of
     * ROLLOVER_IMAGE_MENU_ITEM, ROLLOVER_TEXT_MENU_ITEM, PLAIN_MENU_ITEM.
     * @return The Element created.
     */
    private Element openMenuItemAnchor(DOMOutputBuffer dom,
                                         MenuItem item,
                                         MenuAttributes attributes,
                                         String resolvedHref,
                                         int type)
            throws ProtocolException {

        String value;

        Element element = dom.openStyledElement ("a", item);
        element.setAttribute ("href", resolvedHref);

        // Add a target for the anchor if aggregation is supported and a
        // segment is set.
        boolean supportsAggregation
            = context.getBooleanDevicePolicyValue ("aggregation");

        // Although target is not valid for the <a> tag in XHTMLBasic this
        // is okay because if the device supports aggregation it breaks
        // the DTD for an XHTML-basic device.  As such this should never
        // cause a problem as the device cannot fully validate against the DTD.
        if (supportsAggregation
            && (value = item.getSegment()) != null){
            element.setAttribute ("target", value);
        }

        addCoreAttributes(element, item);
        addMenuItemAttributes (element, item, type);

        return element;
    }

    /**
     * Close an anchor element for the menu item.
     * @param dom The DOMOutputBuffer to use.
     * @param item the MenuItem
     * @param resolvedHref the href of the menu item
     * @param type The type of the menu items being added, must be one of
     * ROLLOVER_IMAGE_MENU_ITEM, ROLLOVER_TEXT_MENU_ITEM, PLAIN_MENU_ITEM.
     */
    protected void closeMenuItemAnchor (DOMOutputBuffer dom,
                                        MenuItem item,
                                        String resolvedHref,
                                        int type) {

        dom.closeElement ("a");
    }

    /**
     * Write out a rollover image
     * @param dom The DOMOutputBuffer to use.
     * @param item the MenuItem
     * @param resolvedHref the anchor
     * @return true if item is written out
     */
    protected boolean doRolloverImage (DOMOutputBuffer dom,
                                       MenuItem item,
                                       String resolvedHref)
            throws ProtocolException {

        return false;
    }

    protected boolean doRolloverText (DOMOutputBuffer dom,
                                      MenuItem item,
                                      String resolvedHref)
            throws ProtocolException {
        return false;
    }

    /**
     * This method appends the output for the menu item to the outStr buffer.
     * @return True if a horizontal separator is required and false otherwise.
     * Images do not require a horizontal separator but text items do.
     */
    protected boolean doMenuItem (DOMOutputBuffer dom,
            MenuAttributes attributes, MenuItem item)
            throws ProtocolException {

        String resolvedHref = getRewrittenLinkFromObject(item.getHref(),
                item.getSegment() != null);

        if (resolvedHref == null) {
            // OK we could not resolve the link. See if there is a fallback
            // TextComponent associated with any LinkComponent that might
            // have been provided.
            String fallbackText =
                getTextFallbackFromLink (item.getHref ());
            if (fallbackText != null) {
                dom.appendEncoded (fallbackText);
            }
            return true;
        }

        // we have a valid href so we can go ahead and procees the menu item
        String type = attributes.getType ();

        // Handle rollover image style menu.
        if ("rolloverimage".equals (type)) {

            // Try and do the rollover image, if any problems occurred then
            // try rollover text.
            if (doRolloverImage (dom, item, resolvedHref)) {
                // Allow subclasses to perform additional menu item processing
                menuItemAddedOK(item, resolvedHref);
                return false;
            }

            type = "rollovertext";
        }

        // Handle rollover text style menu.
        if ("rollovertext".equals (type)) {

            // Try and do the rollover text, if any problems occurred then
            // try a simple menu.
            if (doRolloverText (dom, item, resolvedHref)) {
                // Allow subclasses to perform additional menu item processing
                menuItemAddedOK(item, resolvedHref);
                return true;
            }

            type = "rollovertext";
        }

        // Add the standard anchor stuff to the buffer.
        openMenuItemAnchor (dom, item, resolvedHref, PLAIN_MENU_ITEM);

        dom.appendEncoded (item.getText ());

        closeMenuItemAnchor (dom, item, resolvedHref, PLAIN_MENU_ITEM);

        // Allow subclasses to perform additional menu item processing
        menuItemAddedOK(item, resolvedHref);
        return true;
    }

    /**
     * Method that subclasses should override if they wish to perform
     * additional processing for a menu item
     *
     * @param item the MenuItem object
     * @param resolvedHref the resolved url
     */
    protected void menuItemAddedOK (MenuItem item, String resolvedHref) {
    }

    /* (non-Javadoc)
     * @see com.volantis.mcs.protocols.DOMProtocol#renderMenuItemSeparator(com.volantis.mcs.protocols.DOMOutputBuffer, com.volantis.mcs.protocols.ImageAttributes)
     */
    protected void renderMenuItemSeparator(DOMOutputBuffer dom,
                ImageAttributes imageAttributes) throws ProtocolException {
        doImage(dom, imageAttributes);
    }

    /* (non-Javadoc)
     * @see com.volantis.mcs.protocols.DOMProtocol#renderMenuItemSeparator(com.volantis.mcs.protocols.DOMOutputBuffer, java.lang.String, int)
     */
    protected void renderMenuItemSeparator(DOMOutputBuffer dom,
            String separatorCharacters, int separatorRepeat) {
        for(int i=0;i<separatorRepeat;i++) {
            dom.appendEncoded(separatorCharacters);
        }
    }

    // ========================================================================
    //   Script element methods.
    // ========================================================================

    // ========================================================================
    //   Extended function form element methods.
    // ========================================================================

    // Javadoc inherited from super class.
    public void doForm (XFFormAttributes attributes)
            throws ProtocolException {

        //
        // HTML uses caption as the value field for submit/reset
        // fields. This is not the same as other protocols, so
        // we need to save away the caption in the field descriptor to
        // map back initialValue instead of caption.

        List fields = attributes.getFields ();
        int count = fields.size ();

        for (int i = 0; i < count; i += 1) {
          XFFormFieldAttributes fieldAttributes
              = (XFFormFieldAttributes) fields.get (i);
          FieldDescriptor fieldDescriptor
              = fieldAttributes.getFieldDescriptor ();

          //
          // We are only interested in action fields with names
          //
          if (fieldDescriptor.getType().equals(
              ActionFieldType.getSingleton()) &&
              fieldDescriptor.getName()!=null) {
            //
            // We only want to map fields that have an initial value, otherwise
            // we should default to caption (this is the default behaviour for
            // all protocols).
            //
            if (fieldDescriptor.getInitialValue()!=null) {
                TextAssetReference caption = fieldAttributes.getCaption();
                String captionString = getPlainText(caption);
                fieldDescriptor.setFieldTag(captionString);
              fieldAttributes.setFieldDescriptor(fieldDescriptor);
            }
          }
        }
        //
        // We have done our magic for HTML so lets call the superclass tp
        // do the default form handling
        //
        super.doForm(attributes);
    }

    /**
     * Method to allow subclasses to specify additional attributes for
     * the form element
     * @param element The Element to modify.
     * @param attributes the attributes
     */
    protected void addXFFormAttributes (Element element,
                                        XFFormAttributes attributes)
            throws ProtocolException {
    }

    /**
     * In HTML the relationship between the preamble, content and postamble
     * buffers are as follows:
     * <pre>
     *                   content buffer
     *                _-~      |       ~-_
     *             _-~         |          ~-_
     *          _-~            V             ~-_
     *   preamble buffer     <form>       postamble buffer
     * </pre>
     *
     *
     */
    protected void openForm (XFFormAttributes attributes)
            throws ProtocolException {
        DOMOutputBuffer dom = getContentBuffer (attributes.getFormData ());

        String value;

        // Initialise the title attribute from the prompt attribute, as
        // title is one of the core attributes.
        attributes.setTitle (getPlainText (attributes.getPrompt ()));

        Styles formStyles = attributes.getStyles();
        Element element = dom.openStyledElement ("form", formStyles);

        addCoreAttributes (element, attributes);

        // Note: if action attribute is specified via a LinkComponent
        // and no suitable Link Asset is found it does not make sense
        // to fallback to a TextComonent.
        value = resolveFormAction(attributes);
        if (!value.equals("")) {
            element.setAttribute ("action", value);
        }

        if ((value = attributes.getMethod ()) != null) {
            element.setAttribute ("method", value);
        }

        // allow subclasses to add additional attributes
        addXFFormAttributes (element, attributes);

        // Form elements must be inside a div tag.
        StylingFactory factory = StylingFactory.getDefaultInstance();
        Styles divStyles = factory.createInheritedStyles(formStyles,
                DisplayKeywords.BLOCK);
        dom.openStyledElement ("div", divStyles);

        // Add the top fragment links.
        doTopFragmentLinks (dom, attributes);

        // Add an implicit field which is used to specify the form descriptor.
        Element inputElement = dom.addElement ("input");
        inputElement.setAttribute ("type", "hidden");
        inputElement.setAttribute ("name", URLConstants.FORM_PARAMETER);
        inputElement.setAttribute ("value", getFormSpecifier(attributes));

        // Remember the current insertion point in the dom buffer as that is
        // where we need to insert the contents of the form which will only be
        // generated during the rendering of the layout.
        dom.saveInsertionPoint ();
    }

    // Javadoc inherited.
    public Element createXFormEmulationElement(String formName,
            EmulatedXFormDescriptor fd) {

        Element element = domFactory.createElement();
        element.setName(FORM_EMULATION_ELEMENT);
        element.setAttribute("id", formName);

        // Add the event attributes onto the form element.
        try {
            addFormEventAttributes(element, fd.getFormAttributes());
        } catch (ProtocolException e) {
            throw new ExtendedRuntimeException(e);
        }

        // action attribute is required, so set it even if it resolves to ""
        element.setAttribute ("action",
                resolveFormAction(fd.getFormAttributes()));

        final String method = fd.getFormMethod();
        if (method != null) {
            element.setAttribute ("method", method);
        }
        return element;
    }

    // Javadoc inherited.
    public boolean isXFormEmulationElement(Element element) {
        boolean result = false;
        if (element.getName().equals(FORM_EMULATION_ELEMENT)) {
            result = true;
        }
        return result;
    }
     // Javadoc inherited.
    public boolean isImplicitEmulationElement(Element element) {
       boolean result = false;
        if (element.getName().equals(IMPLICIT_ELEMENT) &&
                "hidden".equalsIgnoreCase(element.getAttributeValue("type"))) {
            result = true;
        }
        return result;
    }

    // Javadoc inherited.
    public Element createVFormElement(String formSpecifier) {
        // Add an implicit field which is used to specify the form descriptor.
        Element inputElement = domFactory.createElement();
        inputElement.setName(IMPLICIT_ELEMENT);
        inputElement.setAttribute ("type", "hidden");
        inputElement.setAttribute ("name", URLConstants.FORM_PARAMETER);
        inputElement.setAttribute ("value", formSpecifier);
        return inputElement;
    }

    // Javadoc inherited.
    public Element validateFormLinkParent(String parentName,
                                          Element parent,
                                          boolean top) {
        Element newParent = parent;
        String newParentName = parentName;
        while(protocolConfiguration.isInvalidFormLinkParent(newParentName)) {
            final String name = protocolConfiguration.
                    getChildForInvalidFormLinkElement(newParentName);
            Element newElement = domFactory.createElement(name);
            if (top) {
                newParent.addHead(newElement);
            } else {
                newParent.addTail(newElement);
            }
            newParent = newElement;
            newParent = validateFormLinkParent(name, newParent, top);
            newParentName = newParent.getName();
        }

        return newParent;
    }

    protected void closeForm (XFFormAttributes attributes)
            throws ProtocolException {

        // Add the bottom fragment links.
        DOMOutputBuffer dom = getContentBuffer (attributes.getFormData ());
        doBottomFragmentLinks (dom, attributes);

        context.clearFormFragmentResetState();

        dom.closeElement ("div");
        dom.closeElement ("form");
    }

    /**
     * Add extra attributes to the text input tag.
     * @param element the mariner element to be updated
     * @param attributes <code>XFTextInputAttributes</code> for the text
     * input form field.
     */
    protected void addTextInputAttributes (Element element,
                                           XFTextInputAttributes attributes)
            throws ProtocolException {
    }

    /**
     * Add extra attributes to the text area tag.
     * @param element the mariner element to be updated
     * @param attributes <code>XFTextInputAttributes</code> for the text
     * input form field.
     */
    protected void addTextAreaAttributes (Element element,
                                          XFTextInputAttributes attributes)
            throws ProtocolException {
    }

    /**
     * Add extra information to the element, or otherwise, which will provide
     * client side validation of the input field.
     * @param element The mariner Element to add client side validation
     * @param attributes {@link XFTextInputAttributes} for the text input field
     */
    protected void addTextInputValidation(Element element,
                                          XFTextInputAttributes attributes)
            throws ProtocolException {
    }

    /**
     * Write out a text input form field to the appropriate pane.
     * @param attributes <code>XFTextInputAttributes</code> for the text
     * input form field.
     */
    public void doTextInput (XFTextInputAttributes attributes)
            throws ProtocolException {

        String value;
        ContainerInstance entryContainerInstance =
                attributes.getEntryContainerInstance ();

        // Write out the caption.
        writeCaption(attributes);

        // If the entry container instance is not set then return as there is
        // nothing else we can do.
        if (entryContainerInstance == null) {
            if(logger.isDebugEnabled()){
                logger.debug ("Entry container instance not set");
            }
            return;
        }

        // Get stylistic information.
        Styles styles = attributes.getStyles();
        String rows = "1";
        String columns = "20";
        if (mcsRowsHandler.isSignificant(styles)) {
            rows = mcsRowsHandler.getAsString(styles);
        }

        if (mcsColumnsHandler.isSignificant(styles)) {
            columns = mcsColumnsHandler.getAsString(styles);
        }

        // Direct the markup to the entry paneInstance's content buffer.
        DOMOutputBuffer dom = getCurrentBuffer(entryContainerInstance);

        // Initialise the title attribute from the prompt attribute, as
        // title is one of the core attributes.
        attributes.setTitle (getPlainText (attributes.getPrompt ()));

        // If the number of rows is 1 then we need to generate a text input
        // tag, otherwise we need to generate a textarea tag.
        if ("1".equals(rows)) {
            Element element = dom.addStyledElement ("input", attributes);

            String tabindex = (String)attributes.getTabindex();
            if (supportsTabindex && tabindex != null) {
                element.setAttribute ("tabindex", tabindex);
            }

            // Append the core attributes to the buffer.
            addCoreAttributes (element, attributes, supportsTitleOnInput);

            // set any attribute values that should be applied for all form fields.
            addFormFieldAttributes(element, attributes);

            element.setAttribute ("name", attributes.getName ());
            element.setAttribute ("type", attributes.getType ());
            element.setAttribute ("size", columns);
            int maxLength = attributes.getMaxLength();
            if(maxLength != -1) {
                element.setAttribute ("maxlength", String.valueOf (maxLength));
            }

            // Get the initial value associated with this field.
            value = getInitialValue (attributes);
            if (value != null) {
                element.setAttribute ("value", value);
            }

            addFormFieldAccessKeyAttribute(element, attributes);

            // Allow subclasses to add extra attributes to the text input.
            addTextInputAttributes (element, attributes);

            addTextInputValidation(element, attributes);
        } else {
            Element element = dom.openStyledElement ("textarea", attributes);

            // Append the core attributes to the buffer.
            addCoreAttributes (element, attributes);

            // set any attribute values that should be applied for all form fields.
            addFormFieldAttributes(element, attributes);

            element.setAttribute ("name", attributes.getName ());
            element.setAttribute ("rows", rows);
            element.setAttribute ("cols", columns);

            int maxLength = attributes.getMaxLength();
            if(maxLength != -1) {
                element.setAttribute ("maxlength", String.valueOf (maxLength));
            }

            addFormFieldAccessKeyAttribute(element, attributes);

            // Allow subclasses to add extra attributes to the text area.
            addTextAreaAttributes (element, attributes);

            // Get the initial value associated with this field.
            value = getInitialValue (attributes);
            if (value != null) {
                dom.appendEncoded (value);
            }

            dom.closeElement ("textarea");
        }
        
        // Registers text input attributes for future retrieval.
        // Used by widget module and multiple validator renderer.
        registerFormFieldAttributes(attributes);
    }

    /**
     * Write out a input form field of type &quot;file&quot; to the appropriate pane.
     * @param attributes <code>XFUploadAttributes</code> for the input form field.
     */
    public void doUpload (XFUploadAttributes attributes)
            throws ProtocolException {

        String value;
        ContainerInstance entryContainerInstance =
                attributes.getEntryContainerInstance ();

        // Write out the caption.
        writeCaption(attributes);

        // If the entry container instance is not set then return as there is
        // nothing else we can do.
        if (entryContainerInstance == null) {
            if(logger.isDebugEnabled()){
                logger.debug ("Entry container instance not set");
            }
            return;
        }

        // Direct the markup to the entry paneInstance's content buffer.
        DOMOutputBuffer dom = getCurrentBuffer(entryContainerInstance);

        // Initialise the title attribute from the prompt attribute, as
        // title is one of the core attributes.
        attributes.setTitle (getPlainText (attributes.getPrompt ()));

        Element element = dom.addStyledElement ("input", attributes);

        String tabindex = (String)attributes.getTabindex();
        if (supportsTabindex && tabindex != null) {
            element.setAttribute ("tabindex", tabindex);
        }

        // Append the core attributes to the buffer.
        addCoreAttributes (element, attributes, supportsTitleOnInput);

        // set any attribute values that should be applied for all form fields.
        addFormFieldAttributes(element, attributes);

        element.setAttribute ("name", attributes.getName ());
        element.setAttribute ("type", "file");
        int maxLength = attributes.getMaxLength();
        if(maxLength != -1) {
            element.setAttribute ("maxlength", String.valueOf (maxLength));
        }

        // Get the initial value associated with this field.
        value = getInitialValue (attributes);
        if (value != null) {
            element.setAttribute ("value", value);
        }

        addFormFieldAccessKeyAttribute(element, attributes);


        // Upload tag requires that encoding type of the enclosing form
        // is set to "multipart/form-data", so we set it here.

        // Start with the current element of form content buffer...
        DOMOutputBuffer formDom = getContentBuffer(attributes.getFormData());
        Element formElement = formDom.getCurrentElement();
        // ...and traverse it until we find the actual form element
        while (null != formElement && (!"form".equals(formElement.getName()))) {
            formElement = formElement.getParent();
        }
        // If form is found, set the enctype attribute and complain otherwise
        if (null != formElement) {
            formElement.setAttribute("enctype", "multipart/form-data");
        } else {
            logger.warn("file-input-outside-form");
        }
    }

    
    /**
     * Allow subclasses to add extra attributes.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void addBooleanAttributes (Element element,
                                         XFBooleanAttributes attributes)
            throws ProtocolException {
    }

    /**
     * Write out a boolean input form field to the appropriate pane.
     * @param attributes <code>XFBooleanAttributes</code> for the boolean
     * input form field.
     */
    public void doBooleanInput (XFBooleanAttributes attributes)
            throws ProtocolException {

        String value;
        ContainerInstance entryContainerInstance =
                attributes.getEntryContainerInstance();        

        // Write out the caption.
        writeCaption(attributes);

        // If the entry container instance is not set then return as there is
        // nothing else we can do.
        if (entryContainerInstance == null) {
            if(logger.isDebugEnabled()){
                logger.debug ("Entry container instance not set");
            }
            return;
        }

        // Direct the markup to the entry container's content buffer.
        DOMOutputBuffer dom = getCurrentBuffer(entryContainerInstance);

        // Generate the markup.
        Element element = dom.addStyledElement ("input", attributes);

        element.setAttribute ("type", "checkbox");
        String tabindex = (String)attributes.getTabindex();
        if (supportsTabindex && tabindex != null) {
            element.setAttribute ("tabindex", tabindex);
        }

        // Initialise the title attribute from the prompt attribute, as
        // title is one of the core attributes.
        attributes.setTitle (getPlainText (attributes.getPrompt ()));

        addCoreAttributes (element, attributes, supportsTitleOnInput);

        // set any attribute values that should be applied for all form fields.
        addFormFieldAttributes(element, attributes);

        element.setAttribute ("name", attributes.getName ());
        element.setAttribute ("value", "1");

        // Get the initial value associated with this field.
        value = getInitialValue (attributes);
        if ((value != null) && value.equals ("1")) {
            element.setAttribute ("checked", "checked");
        }

        addFormFieldAccessKeyAttribute(element, attributes);

        addBooleanAttributes (element, attributes);
        
        // Registers text input attributes for future retrieval.
        // Used by widget module and multiple validator renderer.
        registerFormFieldAttributes(attributes);
    }

    /**
     * Allow subclasses to add extra attributes.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void addSelectMenuAttributes (Element element,
                                            XFSelectAttributes attributes)
            throws ProtocolException {
    }

    /**
     * Write out a multiple or single select form field to the appropriate
     * pane.
     * @param attributes <code>XFSelectAttributes</code> for the select
     * form field.
     */
    public void doSelectInput(XFSelectAttributes attributes)
            throws ProtocolException {

        ContainerInstance captionContainerInstance =
                attributes.getCaptionContainerInstance();
        ContainerInstance entryContainerInstance =
                attributes.getEntryContainerInstance();
        String caption = getPlainText(attributes.getCaption());

        DOMOutputBuffer captionContainerBuffer = null;
        DOMOutputBuffer entryContainerBuffer = null;
        if (captionContainerInstance != null) {
            captionContainerBuffer =
                    getCurrentBuffer(captionContainerInstance);
        }
        if (entryContainerInstance != null) {
            entryContainerBuffer =
                    getCurrentBuffer(entryContainerInstance);
        }
        BufferSelector selector = createBufferSelector(
            attributes.getInsertAfterEntryPaneNode(),
            attributes.getInsertAfterCaptionPaneNode(),
            entryContainerBuffer,
            captionContainerBuffer,
            getCurrentBuffer(entryContainerInstance));

        // Add the caption to the caption paneInstance.
        if ((captionContainerInstance != null) && (caption != null)) {
            if (selector.getInsertAfterCaptionNode() != null) {
                selector.getCaptionPaneOutputBuffer().appendEncoded(caption);

                // If the entry and caption buffers are the same then there is
                // no need to do the insertAfter...
                if (selector.getEntryPaneOutputBuffer() !=
                    selector.getCaptionPaneOutputBuffer()) {
                    selector.insertAfterCaptionNode();
                }
            } else {
                addToBuffer(captionContainerInstance, caption);
            }
        }

        // If the entry pane is not set then return as there is nothing
        // else we can do.
        if (entryContainerInstance == null) {
            if(logger.isDebugEnabled()){
                logger.debug("Entry pane instance not set");
            }
            return;
        }

        // initialise the title from the
        // ensure that any form fragmentation is considered when
        // determining what should be selected
        updateSelectedOptions(attributes);

        SelectionRenderer selectionRenderer =
                getSelectionRenderer(attributes);

        // Direct the markup to the entry panes content buffer.
        DOMOutputBuffer dom = selector.getEntryPaneOutputBuffer();

        selectionRenderer.renderSelection(attributes, dom);

        if (selector.getInsertAfterEntryNode() != null) {
            selector.insertAfterEntryNode();
        }
        
        // Registers text input attributes for future retrieval.
        // Used by widget module and multiple validator renderer.
        registerFormFieldAttributes(attributes);
    }

    // javadoc inherited from superclass
    private SelectionRenderer
            getSelectionRenderer(XFSelectAttributes attributes) {

        Styles styles = attributes.getStyles();
        PropertyValues propertyValues = styles.getPropertyValues();

        StyleValue listStyle = propertyValues.getComputedValue(
                StylePropertyDetails.MCS_SELECTION_LIST_STYLE);
        SelectionRenderer renderer = null;
        if (listStyle != MCSSelectionListStyleKeywords.CONTROLS) {
            // protocol do not need to be thread-safe so it is OK to do this
            if (null == defaultSelectionRenderer) {
                defaultSelectionRenderer = new DefaultSelectionRenderer();
            }
            renderer = defaultSelectionRenderer;
        } else {
            if (null == controlSelectionRenderer) {
                // protocol do not need to be thread-safe so it is OK to do this
                controlSelectionRenderer = new ControlSelectionRenderer();
            }
            renderer = controlSelectionRenderer;
        }
        return renderer;
    }

    // Javadoc inherited from super class.
    public FieldHandler getFieldHandler (ActionFieldType type) {
        return HTMLActionFieldHandler.getSingleton ();
    }

    /**
     * Allow subclasses to add extra attributes.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    protected void addActionAttributes (Element element,
                                        XFActionAttributes attributes)
            throws ProtocolException {
        addFormFieldAccessKeyAttribute(element, attributes);
    }

    /**
     * Add the access key attribute to a (form field) attributes, if
     * necessary for this protocol.
     * <p>
     * NOTE: would be nice if ANY attributes which supports accesskey could
     * be passed in here, but we'd need a new interface to support that...
     * for example AccessibleElementAttributes?
     *
     * @param element the Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    private void addFormFieldAccessKeyAttribute(Element element,
            XFFormFieldAttributes attributes) {
        String value;
        if (supportsAccessKeyAttribute &&
            (value = getPlainText(attributes.getShortcut())) != null) {
            element.setAttribute ("accesskey", value);
        }
    }

    /**
     * Get the image uri to use for the action image.
     * <p>
     * This code has been moved out into a separate method as it is too complex
     * to be embedded in the doActionInput method. It also may need to be used
     * in different places. The only problem is that this method needs to
     * either return a String which is the URL for an image asset, or a string
     * which is the caption to use if the image could not be found.
     * <p>
     * If java supported multiple return types then it would be possible to
     * simply return a pair of values one of which is the image URI and one of
     * which is the caption. This mechanism would be much more efficient than
     * creating an array of two strings as it would use the stack for returning
     * them.
     * <p>
     * In the absence of multiple return types we have three choices, one is
     * to create and return an array of two strings, one is for the caller to
     * pass in an array of one or two strings which could be used in
     * combination with the return value and one is to use a class variable.
     * I have chosen to use the class variable actionImageCaption.
     * @todo the fourth option is to use a class that contains an image URL and
     * @todo an alt text... (something like ImageAssetReference)
     * <p>
     * <strong>SIDE EFFECT:</strong>
     * This method modifies the actionImageCaption member variable.
     * @return The url for the image, or null.
     */
    protected String getActionImageURL (Styles styles) {

        // Set the actionImageCaption to null.
        actionImageCaption = null;

        // Get the name of the image component.
        if (!supportsImageButtons) {
            // Set src to null to force actionStyle to button later
            return null;
        }

        PropertyValues properties = styles.getPropertyValues();

        // Try the mariner-image property first, if that is not set or it's set
        // to none, then try the mariner-form-action-image property.
        StyleValue styleValue = properties.getComputedValue(
                StylePropertyDetails.MCS_IMAGE);

        if (styleValue == null || styleValue == MCSImageKeywords.NONE) {
            styleValue = properties.getComputedValue(
                    StylePropertyDetails.MCS_FORM_ACTION_IMAGE);
            if (styleValue == null) {
                return null;
            }
        }

        StyleValueType valueType = styleValue.getStyleValueType ();

        if (valueType == StyleValueType.URI) {
            return ((StyleURI)styleValue).getURI();
        } else if (valueType == StyleValueType.COMPONENT_URI) {

            PolicyExpression expression =
                    ((StyleComponentURI) styleValue).getExpression();
            if (expression == null) {
                return null;
            }

            try {
                PolicyReferenceResolver resolver =
                        context.getPolicyReferenceResolver();

                RuntimePolicyReference reference =
                        resolver.resolvePolicyExpression(expression);

                AssetResolver assetResolver = context.getAssetResolver();
                ImageAssetReference image =
                        new DefaultComponentImageAssetReference(reference,
                                assetResolver);
                String url = image.getURL();
                if (url != null) {
                    return url;
                }
                actionImageCaption = getTextFromReference(
                        image.getTextFallback(), TextEncoding.PLAIN);

            } catch (AssetReferenceException e) {
                logger.error ("repository-exception", e);
            }
        } else if (valueType == StyleValueType.TRANSCODABLE_URI) {
            final StyleTranscodableURI transcodableUri =
                (StyleTranscodableURI) styleValue;
            try {
                final TranscodableUrlResolver urlResolver =
                    getMarinerPageContext().getTranscodableUrlResolver();
                return urlResolver.resolve(transcodableUri.getUri());
            } catch (RepositoryException e) {
                logger.error ("repository-exception", e);
            }
        }

        return null;
    }

    /**
     * This method create the submit and reset buttons for forms. For submit
     * button image can also be used. If the specified image not found then
     * more suitable text will be displayed.
     * @param attributes The XFActionAttributes class
     * @throws IllegalArgumentException
     */
    protected void doActionInput (DOMOutputBuffer dom,
                                  XFActionAttributes attributes)
            throws ProtocolException {

        // Get the name of the action, may be null.
        String name = attributes.getName ();

        String caption = getPlainText (attributes.getCaption ());
        String actionType = attributes.getType ();
        String src = null;

        // Treat perform the same as submit. This is not strictly correct
        // as submit does not really have any meaning when the input field
        // is outside a form. However "button" is not supported in HTML 3.2
        // either as an input type or a separate element and no other input
        // type is remotely suitable.
        boolean alwaysCheckForImage = false;
        if (actionType.equals ("perform")) {
            actionType = "submit";

            // An inline action should always check to see whether an image
            // has been specified.
            alwaysCheckForImage = true;
        }

        // Get the form attributes, if they are not set then this is being
        // rendered inline.
        if (actionType.equals ("submit")) {

            Styles styles = attributes.getStyles();

            // Initialise the action style.
            StyleValue actionStyle;
            if (alwaysCheckForImage) {
                actionStyle = MCSFormActionStyleKeywords.IMAGE;
            } else {
                PropertyValues propertyValues = styles.getPropertyValues();
                actionStyle = propertyValues.getComputedValue(
                        StylePropertyDetails.MCS_FORM_ACTION_STYLE);
            }

            if (actionStyle == MCSFormActionStyleKeywords.DEFAULT
                    || actionStyle == MCSFormActionStyleKeywords.LINK) {
                // Just checking.
            } else if (actionStyle == MCSFormActionStyleKeywords.IMAGE) {

                // Get the src url for the image component if any.
                src = getActionImageURL(styles);
                if (src == null) {
                    // No URL was available so the input field is simply
                    // a submit button, as already defined.

                    // If no caption was set then use the one associated
                    // with the image.
                    if (caption == null) {
                        caption = actionImageCaption;
                    }
                } else {
                    // An image was found so change the action type to
                    // image.
                    actionType = "image";

                    // The caption is not required so don't use it.
                    caption = null;
                }
            } else {
                throw new IllegalArgumentException(
                        "Unknown action style " + actionStyle);
            }

        } else if (actionType.equals ("reset")) {
            // Just checking
        } else {
            throw new IllegalArgumentException ();
        }

        Element element = createActionElement(dom,
                                              actionType,
                                              name,
                                              caption,
                                              src,
                                              attributes);

        String tabindex = (String)attributes.getTabindex();
        if (supportsTabindex && tabindex != null) {
            element.setAttribute ("tabindex", tabindex);
        }

        // Initialise the title attribute from the prompt attribute, as
        // title is one of the core attributes.
        attributes.setTitle (getPlainText (attributes.getPrompt ()));

        addCoreAttributes (element, attributes, supportsTitleOnInput);

        // set any attribute values that should be applied for all form fields.
        addFormFieldAttributes(element, attributes);

        addActionAttributes (element, attributes);
    }


    /**
     * Create the action element with the type, name, value and src attributes
     * set.
     * @param dom the DOM transformer used to add / open Elements
     * @param actionType the type of the action 'image', 'button', etc.
     * @param name the name of the element
     * @param caption the caption for this element
     * @param src the src of the element
     * @param styleContainer contains the element's style information
     * @return a new Element based on the parameters passed in.
     */
    protected Element createActionElement(DOMOutputBuffer dom,
                                          String actionType,
                                          String name,
                                          String caption,
                                          String src,
                                          StyleContainer styleContainer) {
      // Now build up the HTML tag.
      Element element = dom.addStyledElement ("input", styleContainer);

      element.setAttribute ("type", actionType);

      // If the name has been specified then make sure that we also generate
      // a value, even if it is blank.
      if (name != null) {
          // We have to use the caption as the value because of a limitation
          // in the X/HTML forms as the buttons use the value as both the
          // caption and the value. However, we fix this up when we process
          // the form information.
          element.setAttribute ("name", name);
          if (caption != null) {
              element.setAttribute ("value", caption);
          }

      } else if (caption != null) {
          element.setAttribute ("value", caption);
      }

      if (src != null) {
          element.setAttribute ("src", src);
      }
      return element;
    }

    // Javadoc inherited.
    public void doImplicitValue (DOMOutputBuffer dom,
            XFImplicitAttributes attributes) {
        // In XHTMLBasic we add an implicit value to the form by adding a
        // hidden field to the form preamble buffer.
        Element element = dom.addStyledElement ("input", attributes);
        addFormFieldAttributes(element, attributes);
        element.setAttribute ("type", "hidden");
        element.setAttribute ("name", attributes.getName ());
        element.setAttribute ("value", attributes.getValue ());
        
        // Registers text input attributes for future retrieval.
        // Used by widget module and multiple validator renderer.
        registerFormFieldAttributes(attributes);
    }


    /**
     * Allow subclasses to add extra attributes.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    private void addSubscriptAttributes (Element element,
                                           SubscriptAttributes attributes) {
    }

    // Javadoc inherited from sub class.
    protected void openSubscript (DOMOutputBuffer dom,
                                  SubscriptAttributes attributes)
            throws ProtocolException {

        Element element = createSubScriptElement(dom, attributes);

        addCoreAttributes (element, attributes);

        // Add the general event attributes.
        addGeneralEventAttributes (element, attributes);

        addSubscriptAttributes (element, attributes);
    }

    // Javadoc inherited from sub class.
    protected void closeSubscript (DOMOutputBuffer dom,
                                   SubscriptAttributes attributes) {
        dom.closeElement (getSubScriptElementType());
    }

    /**
     * Determine the element type for a subscript element
     * @return the element type
     */
    private Element createSubScriptElement(DOMOutputBuffer dom,
                                       SubscriptAttributes attributes) {

        //determine if the SubScript element is supported
        String elementType = "sub";
        if (!protocolConfiguration.getCanSupportSuperScriptElement()) {
            elementType = "span";
        } else {
            MCSAttributeStylePropertyFilter.filterOutAttributeDefaultValues(
                    protocolConfiguration, elementType, attributes,
                                    new StyleProperty[] {
                                        StylePropertyDetails.VERTICAL_ALIGN,
                                        StylePropertyDetails.FONT_SIZE
                                    }
            );
        }

        Element element = dom.openStyledElement (elementType, attributes);

        return element;
    }

    /**
     * Get the element type for a SubScript element
     * @return
     */
    private String getSubScriptElementType() {
        String elementType = "sub";
        if (!protocolConfiguration.getCanSupportSubScriptElement()) {
            elementType = "span";
        }
        return elementType;
    }

    /**
     * Allow subclasses to add extra attributes.
     * @param element The Element to modify.
     * @param attributes The attributes to use when generating the markup.
     */
    private void addSuperscriptAttributes (Element element,
                                       SuperscriptAttributes attributes) {
    }

    // Javadoc inherited from super class.
    protected void openSuperscript (DOMOutputBuffer dom,
                                    SuperscriptAttributes attributes)
            throws ProtocolException {

        Element element = createSuperScriptElement(dom, attributes);

        addCoreAttributes (element, attributes);

        // Add the general event attributes.
        addGeneralEventAttributes (element, attributes);

        addSuperscriptAttributes (element, attributes);
    }

    // Javadoc inherited from super class.
    protected void closeSuperscript (DOMOutputBuffer dom,
                                     SuperscriptAttributes attributes) {
        dom.closeElement (getSuperScriptElementType());
    }

    /**
     * Determine the element type for a superscript element
     * @return the element type
     */
    private Element createSuperScriptElement(DOMOutputBuffer dom,
                                       SuperscriptAttributes attributes) {

        //determine if the SuperScript element is supported
        String elementType = "sup";
        if (!protocolConfiguration.getCanSupportSuperScriptElement()) {
            elementType = "span";
        } else {
            MCSAttributeStylePropertyFilter.filterOutAttributeDefaultValues(
                    protocolConfiguration, elementType, attributes,
                                    new StyleProperty[] {
                                        StylePropertyDetails.VERTICAL_ALIGN,
                                        StylePropertyDetails.FONT_SIZE
                                    }
            );
        }

        Element element = dom.openStyledElement (elementType, attributes);

        return element;
    }

    /**
     * Get the element type for a SuperScript element
     * @return
     */
    private String getSuperScriptElementType() {
        String elementType = "sup";
        if (!protocolConfiguration.getCanSupportSuperScriptElement()) {
            elementType = "span";
        }
        return elementType;
    }

    // Javadoc inherited from super class
    public WidgetModule getWidgetModule(){
        return widgetModule;
    }
    
    // Javadoc inherited from super class
    public TickerModule getTickerModule(){
        return tickerModule;
    }
    
    // Javadoc inherited from super class
    public GalleryModule getGalleryModule(){
        return galleryModule;
    }

    // Javadoc inherited
    public void writeTimedRefresh(TimedRefreshInfo refreshInfo)
            throws ProtocolException{
        
        if (DevicePolicyConstants.FULL_SUPPORT_POLICY_VALUE.equals(
            context.getDevicePolicyValue(
                X_ELEMENT_SUPPORTS_META_REFRESH))) {
            if (logger.isDebugEnabled()) {
                logger.debug("writing timed refresh meta");
            }
            MetaAttributes attributes = new MetaAttributes();
            attributes.setHttpEquiv(TimedRefreshInfo.NAME);
            attributes.setContent(refreshInfo.getHTMLContent(context));


            DOMOutputBuffer dom =
                (DOMOutputBuffer) context.getProtocol().getPageHead().getHead();
            doMeta(dom, attributes);
        } else {
            if (logger.isDebugEnabled()) {
                logger.debug("writing timed refresh meta is not " +
                             "supported on this device");
            }
        }
    }

    /**
     * Creates an instance of TickerResponseModule, for use with this protocol.
     * This method is invoked once, during protocol initialization.
     * 
     * @return An instance of TickerResponseModule.
     */
    protected TickerResponseModule createTickerResponseModule() {
        try {
            // Because XHTMLBasicTickerResponseModule is defined in 'impl',
            // it needs to be instantiated using reflection.
            return (TickerResponseModule) Class.forName("com.volantis.mcs.protocols.ticker.response.XHTMLBasicTickerResponseModule").
            getConstructor(new Class[]{XHTMLBasic.class}).
            newInstance(new Object[]{this});
        } catch (Exception e) {
            throw new RuntimeException("Cannot instantiate XHTMLBasicTickerResponseModule", e);
        }
    }    

    /**
     * Add an event attribute to the StringOutputBuffer.
     * @param element The Element to modify.
     * @param attributeName The name of the attributes.
     * @param userScript The user script.
     * @param internalScript Any internal script that we add.
     */
    protected void addEventAttribute(Element element, String attributeName,
            ScriptAssetReference userScript, String internalScript)
            throws ProtocolException {

        String script = null;

        if (userScript != null) {
            Script scriptObject = Script.createScript(userScript);
            if (logger.isDebugEnabled ()) {
                logger.debug ("User script for " + attributeName
                              + " is " + scriptObject);
            }
            if (scriptObject != null) {
                script = scriptObject.stringValue();
            }
        }

        if (internalScript != null) {
            if (logger.isDebugEnabled ()) {
                logger.debug ("Internal script for " + attributeName
                              + " is " + internalScript);
            }
            if (script == null) {
                script = internalScript;
            } else {
                script = scriptHandler.joinScripts (this, script,
                                                    internalScript);

                if (logger.isDebugEnabled ()) {
                    logger.debug ("Joined script " + attributeName
                                  + " is " + script);
                }
            }
        }

        if (script != null) {
            element.setAttribute (attributeName, script.trim ());
        }
    }

    /**
     * Add event attributes.
     * @param element The Element to modify.
     * @param attributes The attributes object.
     * @param eventAttributeNames An array of the names of the event
     * attributes.
     * @param supportedEventsMask A mask of the events which are supported
     * on the current element.
     */
    protected void addEventAttributes(Element element,
            MCSAttributes attributes, String[] eventAttributeNames,
            int supportedEventsMask) throws ProtocolException {

        if (!protocolConfiguration.supportsEvents()) {
            return;
        }

        EventAttributes eventAttributes
            = attributes.getEventAttributes (false);
        if (eventAttributes == null) {
            return;
        }

        int bit = 1;
        for (int i = 0; i < EventConstants.MAX_EVENTS;
             i += 1, bit = bit << 1) {

            // If the attribute name is not specified then ignore it.
            String attributeName = eventAttributeNames [i];
            if (attributeName == null) {
                continue;
            }

            // If the supportedEvents mask doesn't have the bit associated
            // with the current event set then ignore it.
            if ((supportedEventsMask & bit) != bit) {
                continue;
            }

            ScriptAssetReference userScript = eventAttributes.getEvent (i);

            addEventAttribute (element, attributeName, userScript, null);
        }
    }

    /**
     * Add general event attributes.
     * @param element The Element to modify.
     * @param attributes The attributes object which contains the events.
     */
    protected
        void addGeneralEventAttributes (Element element,
            MCSAttributes attributes) throws ProtocolException {

        // todo: later: this should not have forward reference to XHTMLFull
        addEventAttributes (element, attributes, XHTMLFull.eventAttributeNames,
                            protocolConfiguration.getSupportedGeneralEvents());
    }

    /**
     * Add form event attributes.
     * @param element The Element to modify.
     * @param attributes The attributes object which contains the events.
     */
    protected
        void addFormEventAttributes (Element element,
            MCSAttributes attributes) throws ProtocolException {

    }


    /**
     * Provide a default implementation of the SelectionRenderer.
     */
    protected final class DefaultSelectionRenderer
            implements SelectionRenderer {

        private XFSelectAttributes attributes;

        private final RenderingVisitor visitor;

        public DefaultSelectionRenderer() {
            visitor = new RenderingVisitor();
        }

        /**
         * Render the attributes and style into the output buffer.
         *
         * @param  attributes        <code>XFSelectAttributes</code>
         * @param  buffer            the <code>OutputBuffer</code>
         * @throws ProtocolException
         */
        public void renderSelection(
                XFSelectAttributes attributes,
                OutputBuffer buffer)
                throws ProtocolException {

            this.attributes = attributes;

            DOMOutputBuffer dom = (DOMOutputBuffer) buffer;
            openSelect(dom);
            renderOptions(dom);
            closeSelect(dom);
        }

        protected void openSelect(DOMOutputBuffer dom)
                throws ProtocolException {

            Styles styles = attributes.getStyles();


            // we need to write out a standard <select>
            Element element = dom.openStyledElement("select", attributes);

            // Initialise the title attribute from the prompt attribute, as
            // title is one of the core attributes.
            // Need to fully qualify access to outer class due to bug in the
            // Sun 1.2 jdk compiler
            String title = getPlainText(attributes.getPrompt());
            attributes.setTitle(title);

            String tabindex = (String) attributes.getTabindex();
            if (supportsTabindex && tabindex != null) {
                element.setAttribute("tabindex", tabindex);
            }

            addCoreAttributes(element, attributes);

            // set any attribute values that should be applied for all form fields.
            addFormFieldAttributes(element, attributes);

            element.setAttribute("name", attributes.getName());

            if (attributes.isMultiple()) {
                if (mcsRowsHandler.isSignificant(styles)) {
                    element.setAttribute("size",
                            mcsRowsHandler.getAsString(styles));
                }
                element.setAttribute("multiple", "multiple");
            }

            // allow subclasses of the protocol to add extra
            addSelectMenuAttributes(element, attributes);
        }

        protected void closeSelect(DOMOutputBuffer dom) {
            dom.closeElement("select");
        }

        private void renderOptions(DOMOutputBuffer dom)
                throws ProtocolException {
            renderOptions(attributes.getOptions(), dom);
        }

        private void renderOptions(List options, DOMOutputBuffer dom)
                throws ProtocolException {
            Option option;
            for (int i = 0; i < options.size(); i++) {
                option = (Option) options.get(i);
                option.visit(visitor, dom);
            }
        }

        /**
         * Render the Default style options.
         */
        private class RenderingVisitor implements OptionVisitor {

            public void visit(SelectOption option,
                              Object object) {

                DOMOutputBuffer dom = (DOMOutputBuffer) object;
                // Need to fully qualify access to outer class due to bug in
                // the Sun 1.2 jdk compiler
                String title = getPlainText(option.getPrompt());
                option.setTitle(title);

                // Create the option element.
                Element optionElement = dom.openStyledElement("option", option);

                // core attributes.
                addCoreAttributes(optionElement, option,
                                  supportsTitleOnOption);

                String value = option.getValue();

                // Get the caption from the object, if it is null then use the
                // value from option.getValue().
                // Need to fully qualify access to outer class due to bug in
                // the Sun 1.2 jdk compiler.
                String caption = getPlainText(option.getCaption());
                if (caption == null) {
                    caption = value;
                }

                if (value != null) {
                    optionElement.setAttribute("value", value);
                }

                if (option.isSelected()) {
                    optionElement.setAttribute("selected", "selected");
                }
                if (caption != null) {
                    dom.appendEncoded(caption);
                }
                // close the option
                dom.closeElement(optionElement);
            }

            // javadoc inherited
            public void visit(SelectOptionGroup optionGroup,
                              Object object) throws ProtocolException {
                // write out the option group
                DOMOutputBuffer dom = (DOMOutputBuffer)object;

                boolean writeOptGroup = (-1 == maxOptgroupDepth ||
                        currentOptgroupDepth < maxOptgroupDepth);

                if (writeOptGroup) {
                    currentOptgroupDepth++;

                    Element element = dom.openStyledElement("optgroup", optionGroup);

                    // Need to fully qualify access to outer class due to bug
                    // in the Sun 1.2 jdk compiler
                    String title = getPlainText(optionGroup.getPrompt());

                    optionGroup.setTitle(title);

                    addCoreAttributes(element, optionGroup,
                                      supportsTitleOnOptionGroup);

                    // Need to fully qualify access to outer class due to bug
                    // in the Sun 1.2 jdk compiler
                    String caption = getPlainText(optionGroup.getCaption());

                    element.setAttribute("label", caption);
                }

                // render any option/ option group
                renderOptions(optionGroup.getSelectOptionList(), dom);

                if (writeOptGroup) {
                    currentOptgroupDepth--;
                    dom.closeElement("optgroup");
                }
            }
        }
    }

    /**
     * Class that renders a checkbox/radio button select control.
     */
    protected final class ControlSelectionRenderer
        implements SelectionRenderer {

        private XFSelectAttributes selectAttributes;

        private boolean alignCaptionRight;

        private boolean verticalOptions;

        private int optionCount;

        private final RenderingVisitor visitor;

        /**
         * Maintain a map of insertAfterCaptionNode to actual nodes. This is
         * necessary in order to ensure nodes are output in the correct order
         * if more than one option has an insertAfterNode.
         * <p>
         * For example, if we have insertAfterNode = Node("br") for option("1")
         * and option("2") then option 1 will be mapped to Node("br"). When
         * option 1 is processed, update the map so that subsequent options
         * with the same insertAfterNode may access the a correct insertAfter
         * Node (this will be option("1").getNext().
         */
        private Map insertAfterCaptionNodeMap;

        /**
         * Maintain a map of insertAfterEntryNode to actual nodes. This is
         * necessary in order to ensure nodes are output in the correct order.
         *
         * @see #insertAfterCaptionNodeMap
         */
        private Map insertAfterEntryNodeMap;

        public ControlSelectionRenderer() {
            visitor = new RenderingVisitor();
        }


        /**
         * Initialise the member variables that are need in order to
         * perform a render. Unfortunately these variables have to be
         * stored away as member variables as they OptionVisitor requires
         * access to them.
         * @param attributes the XFSelectAttributes.
         */
        private void initialise(XFSelectAttributes attributes) {
            this.selectAttributes = attributes;

            Styles styles = attributes.getStyles();
            PropertyValues propertyValues = styles.getPropertyValues();
            StyleValue styleValue;

            styleValue = propertyValues.getComputedValue(
                    StylePropertyDetails.MCS_SELECTION_LIST_OPTION_LAYOUT);
            this.alignCaptionRight =
                    (styleValue == MCSSelectionListOptionLayoutKeywords.CONTROL_FIRST);

            styleValue = propertyValues.getComputedValue(
                    StylePropertyDetails.MCS_MENU_ORIENTATION);
            this.verticalOptions =
                    (styleValue == MCSMenuOrientationKeywords.VERTICAL);

            optionCount = 0;
        }

        // javadoc inherited.
        public void renderSelection(
                XFSelectAttributes attributes,
                OutputBuffer buffer)
                throws ProtocolException {

            initialise(attributes);
            DOMOutputBuffer dom = (DOMOutputBuffer) buffer;

            // open the div
            DivAttributes da = new DivAttributes();
            da.copy(attributes);

            // Make sure that the display value is block, rather than the
            // default for xfsi/muselect which is inline.
            Styles styles = da.getStyles();
            MutablePropertyValues propertyValues = styles.getPropertyValues();
            propertyValues.setComputedValue(StylePropertyDetails.DISPLAY,
                    DisplayKeywords.BLOCK);

            da.setId(attributes.getId());
            openDiv(dom, da);

            // render any options
            renderOptions(dom);

            // close the div
            closeDiv(dom, da);

        }

        /**
         * Render the options to the dom output buffer.
         *
         * @param  dom               the DOM output buffer.
         * @throws ProtocolException
         */
        private void renderOptions(DOMOutputBuffer dom)
                throws ProtocolException {
            renderOptions(selectAttributes.getOptions(), dom);
        }

        /**
         * Render the list of options to the dom output buffer.
         *
         * @param  options           the list of options.
         * @param  dom               the DOM output buffer.
         * @throws ProtocolException
         */
        private void renderOptions(List options, DOMOutputBuffer dom)
                throws ProtocolException {
            Option option;
            for (int i = 0; i < options.size(); i++) {
                option = (Option) options.get(i);
                option.visit(visitor, dom);
            }
        }

        /**
         * Get the insert after node given the map and the node.
         *
         * @param  nodeMap         the map used to look up the insert after
         *                         node.
         * @param  insertAfterNode the insert after node.
         * @return                 the insert after node given the map and the
         *                         node.
         */
        private Node getInsertAfterNode(final Map nodeMap,
                                        final Node insertAfterNode) {
            Node result = null;
            if (insertAfterNode != null) {
                result = insertAfterNode;
                Node node = (Node) nodeMap.get(insertAfterNode);
                if (node != null) {
                    Node next = node.getNext();
                    if (next != null) {
                        result = next;
                    }
                }
                // Always update the map.
                nodeMap.put(insertAfterNode, result);
            }
            return result;
        }

        /**
         * Write the <code>SelectOption</code> to the DOMOutputBuffer.
         *
         * @param  dom               the <code>DOMOutputBuffer</code>
         * @param  option            the select option.
         * @throws ProtocolException
         */
        protected void writeOption(DOMOutputBuffer dom, SelectOption option)
                throws ProtocolException {

            // Need to fully qualify access to outer class due to bug in the
            // Sun 1.2 jdk compiler
            String title = getPlainText(option.getPrompt());

            option.setTitle(title);

            // We have an insertAfter caption and/or entry node. We need to
            // create a DOMOutputBuffer for each type (may be the same) and then
            // generate the output to the selector. The root element of this
            // buffer will be inserted after the stored insertAfter element.
            DOMOutputBuffer captionPaneBuffer = null;
            DOMOutputBuffer entryPaneBuffer = null;
            if (option.getCaptionContainerInstance() != null) {
                captionPaneBuffer = getCurrentBuffer(option.getCaptionContainerInstance());
            }
            if (option.getEntryContainerInstance() != null) {
                entryPaneBuffer = getCurrentBuffer(option.getEntryContainerInstance());
            }

            BufferSelector selector = createBufferSelector(
                option.getInsertAfterEntryPaneNode(),
                option.getInsertAfterCaptionPaneNode(),
                entryPaneBuffer,
                captionPaneBuffer,
                dom
            );

            final Node insertAfterCaptionNode = selector.getInsertAfterCaptionNode();
            // Insert root of ONE buffer to insertAfter node
            if (insertAfterCaptionNode != null) {

                if (insertAfterCaptionNodeMap == null) {
                    insertAfterCaptionNodeMap = new HashMap();
                }
                selector.insertAfterCaptionNode(
                    getInsertAfterNode(insertAfterCaptionNodeMap,
                                       insertAfterCaptionNode));
            }

            if (selector.getInsertAfterEntryNode() != insertAfterCaptionNode) {
                // Both nodes are different (one may be null) so insert root
                // of each buffer to 'insertAfter' node.
                Node insertAfterEntryNode = selector.getInsertAfterEntryNode();
                if (insertAfterEntryNode != null) {
                    if (insertAfterEntryNodeMap == null) {
                        insertAfterEntryNodeMap = new HashMap();
                    }
                    selector.insertAfterEntryNode(
                        getInsertAfterNode(insertAfterEntryNodeMap,
                                           insertAfterEntryNode));
                }
            }

            captionPaneBuffer = selector.getCaptionPaneOutputBuffer();
            entryPaneBuffer = selector.getEntryPaneOutputBuffer();

            boolean writeSeperator = (optionCount++ > 0);
            boolean hasDedicatedCaptionPane = (captionPaneBuffer != entryPaneBuffer);

            // if we need to write out a seperator then do it now
            if (!hasDedicatedCaptionPane && writeSeperator) {
                if (verticalOptions) {
                    addVerticalMenuItemSeparator(captionPaneBuffer);
                } else {
                    addHorizontalMenuItemSeparator(entryPaneBuffer);
                }
            }

            // write out the caption now if there is a dedicated captionPane or
            // the caption is to be aligned to the left of the option
            if (hasDedicatedCaptionPane || !alignCaptionRight) {
                // write caption to the dedicated caption pane
                writeOptionCaption(option, selectAttributes, captionPaneBuffer);
            }

            // write out the option
            Element element = entryPaneBuffer.addStyledElement("input", option);

            // set any attribute values that should be applied for all form fields.
            addFormFieldAttributes(element, selectAttributes);

            String tabindex = (String) selectAttributes.getTabindex();
            if (supportsTabindex && tabindex != null) {
                element.setAttribute("tabindex", tabindex);
            }

            addCoreAttributes(element, option, supportsTitleOnInput);

            String selectType = selectAttributes.isMultiple()
                    ? "checkbox" : "radio";

            element.setAttribute("type", selectType);
            element.setAttribute("name", selectAttributes.getName());
            if (option.getValue() != null) {
                element.setAttribute("value", option.getValue());
            }

            // allow subclasses of the protocol to add extra
            addSelectMenuAttributes(element, selectAttributes);

            if (option.isSelected()) {
                element.setAttribute("checked", "checked");
            }

            // need to write the caption if it is not already written out
            if (!hasDedicatedCaptionPane && alignCaptionRight) {
                writeOptionCaption(option, selectAttributes, captionPaneBuffer);
            }
        }

        /**
         * Write out the caption for a Control Option (checkbox/radio button)
         * @param option the option
         * @param attributes the attributes for the parent select element
         * @param dom
         */
        protected void writeOptionCaption(SelectOption option,
                                          XFSelectAttributes attributes,
                                          DOMOutputBuffer dom)
                throws ProtocolException {
            String value = option.getValue();

            // Get the caption from the object, if it is null then use the
            // value.
            // Need to fully qualify access to outer class due to bug in the
            // Sun 1.2 jdk compiler
            String caption = getPlainText(option.getCaption());

            if (null == caption) {
                caption = value;
            }

            SpanAttributes sa = null;
            final Styles captionStyles = option.getCaptionStyles();
            if (null != captionStyles) {
                sa = new SpanAttributes();
                sa.setStyles(captionStyles);
                openSpan(dom, sa);
            }

            dom.appendEncoded(caption);

            if (null != captionStyles) {
                closeSpan(dom, sa);
            }
        }

        /**
         * Inner class rendering visitor.
         */
        private class RenderingVisitor implements OptionVisitor {

            // javadoc inherited
            public void visit(SelectOption selectOption,
                              Object object) throws ProtocolException {
                // write out the option
                writeOption((DOMOutputBuffer) object, selectOption);
            }

            // javadoc inherited
            public void visit(SelectOptionGroup optionGroup,
                              Object object) throws ProtocolException {
                // control options cannot be enclosed in an optgroup.
                // just write out any nested options
                renderOptions(optionGroup.getSelectOptionList(),
                              (DOMOutputBuffer) object);
            }
        }
    }

    // ========================================================================
    //   Fallback methods
    // ========================================================================

    /**
     * This impl. writes out a SPAN instead of the default P around the alt
     * text so as not to disturb whitespace in the page.
     * <p>
     * It may be that SPAN is a better default than P anyway, but that would
     * be a larger change which I do not have permission to do at the moment.
     */
    protected void renderAltText(String altText,
            MCSAttributes attributes) throws ProtocolException {
        // Copy the tag attrs into something we can use with SPAN
        SpanAttributes spanAttrs = new SpanAttributes ();
        spanAttrs.copy(attributes);
        // Write out a SPAN tag with the fallback text in it, using the
        // styles of the original PAPI tag.
        writeOpenSpan (spanAttrs);
        OutputBufferWriter writer = getContentWriter();
        try {
            writer.write (altText);
        } catch (IOException e) {
            logger.error("unexpected-ioexception", e);
        }
        writeCloseSpan (spanAttrs);
    }


    protected DOMOutputBuffer getCurrentBuffer() {
        return super.getCurrentBuffer();
    }

    /**
     * Returns the OutputBuffer in which native markup will be written.
     *
     * @param attributes Attributes that determine the output buffer to use
     * @return OutputBuffer the output buffer to be used
     * @throws ProtocolException if there is a problem with the attribute
     *                           settings or in processing the request
     */
    protected OutputBuffer getNativeMarkupOutputBuffer(
        NativeMarkupAttributes attributes) throws ProtocolException {
        String target = attributes.getTargetLocation();

        OutputBuffer buffer = null;

        if (NativeMarkupAttributes.HTML_HEAD.equals(target)) {
            if (logger.isDebugEnabled()) {
                logger.debug("nativemarkup goes in head element");
            }
            buffer = getHeadBuffer();
        } else {
            buffer = super.getNativeMarkupOutputBuffer(attributes);
        }

        return buffer;
    }


    /**
     * Create the buffer selector object.
     *
     * @param  insertAfterEntryNode   the node after which the
     *                                insertAfterEntryNode (option) should go.
     * @param  insertAfterCaptionNode the node after which the
     *                                insertAfterCaptionNode should go.
     * @param  entryPaneBuffer        the entryPane buffer (not null).
     * @param  captionPaneBuffer      the captionPane buffer (not null).
     * @param  dom                    the dom output buffer.
     * @return                        the BufferSelector with the correct
     *                                buffers for the insertAfterCaptionNode
     *                                and insertAfterEntryNode panes.
     */
    protected BufferSelector createBufferSelector(
        Node insertAfterEntryNode,
        Node insertAfterCaptionNode,
        DOMOutputBuffer entryPaneBuffer,
        DOMOutputBuffer captionPaneBuffer,
        DOMOutputBuffer dom) {

        return new BufferSelector(insertAfterEntryNode, insertAfterCaptionNode,
            entryPaneBuffer, captionPaneBuffer, dom);
    }

    /**
     * This class takes a number of inputs which are used to determine which
     * buffers to use for the entry and caption panes.
     *
     * Note the the resulting buffers may be the same buffer, ie.
     * entryPaneBuffer == captionPaneBuffer.
     */
    protected static final class BufferSelector {

        private DOMOutputBuffer entryPaneBuffer;
        private DOMOutputBuffer captionPaneBuffer;

        private final Node insertAfterEntryNode;
        private final Node insertAfterCaptionNode;


        /**
         * Create the BufferSelector object with the required parameters and
         * immediately initialize the buffers (perform the selection and store
         * the result).
         *
         * @param insertAfterEntryNode   the insertAfterEntryNode node
         * @param insertAfterCaptionNode the insertAfterCaption node
         * @param entryPaneBuf           the insertAfterEntryNode pane's
         *                               buffer.
         * @param captionPaneBuf         the insertAfterCaptionNode pane's
         *                               buffer.
         * @param dom                    the default dom to use if both
         */
        protected BufferSelector(
                Node insertAfterEntryNode,
                Node insertAfterCaptionNode,
                DOMOutputBuffer entryPaneBuf,
                DOMOutputBuffer captionPaneBuf,
                DOMOutputBuffer dom) {
            this.insertAfterEntryNode = insertAfterEntryNode;
            this.insertAfterCaptionNode = insertAfterCaptionNode;
            initialize(entryPaneBuf, captionPaneBuf, dom);
        }

        /**
         * Get the updated insertAfterEntryNode.
         *
         * @return      the updated insertAfterEntryNode.
         */
        protected Node getInsertAfterEntryNode() {
            return insertAfterEntryNode;
        }

        /**
         * Get the updated insertAfterCaptionNode.
         *
         * @return      the updated insertAfterCaptionNode.
         */
        protected Node getInsertAfterCaptionNode() {
            return insertAfterCaptionNode;
        }

        /**
         * Get the output buffer after initialization.
         *
         * @return      the output buffer after initialization.
         */
        protected DOMOutputBuffer getEntryPaneOutputBuffer() {
            return entryPaneBuffer;
        }

        /**
         * Get the output buffer after initialization.
         *
         * @return      the output buffer after initialization.
         */
        protected DOMOutputBuffer getCaptionPaneOutputBuffer() {
            return captionPaneBuffer;
        }

        /**
         * Initialize the buffers given the various states of the nodes and or panes.
         */
        private void initialize(
                final DOMOutputBuffer entryPaneBuf,
                final DOMOutputBuffer captionPaneBuf,
                final DOMOutputBuffer dom) {

            // Default to using the captionPane and entryPane buffers.
            captionPaneBuffer = captionPaneBuf;
            entryPaneBuffer = entryPaneBuf;

            // If we have an insertAfterCaptionNode node, create use a newly
            // created buffer for it.
            if (insertAfterCaptionNode != null) {
                captionPaneBuffer = new DOMOutputBuffer();
                captionPaneBuffer.initialise();
            }
            // If we have an insertAfterEntryNode node, create use a newly
            // created buffer for it (if it is not the same as the
            // insertAfterCaptionNode).
            if (insertAfterEntryNode != null) {
                if (insertAfterCaptionNode == insertAfterEntryNode) {
                    entryPaneBuffer = captionPaneBuffer;
                } else {
                    // Nodes are different so require 2 different buffers.
                    // Just need to update the entryPaneBuffer now.
                    entryPaneBuffer = new DOMOutputBuffer();
                    entryPaneBuffer.initialise();
                }
            }
            // if the entry buffer is null then try to make it the same as
            // the captionPaneBuffer.
            if (entryPaneBuffer == null) {
                entryPaneBuffer = captionPaneBuffer;
            }

            // if the captionPaneBuffer is null then try to make it the same as
            // the entryPaneBuffer.
            if (captionPaneBuffer == null) {
                captionPaneBuffer = entryPaneBuffer;
            }

            // if the captionPaneBuffer is still null then both are null so we
            // make them both equal to the dom parameter which should be the
            // entrypane of the parent select.
            if (captionPaneBuffer == null) {
                captionPaneBuffer = entryPaneBuffer = dom;
            }
        }

        /**
         * Insert the caption buffer's root element after the stored caption node.
         * @param node the node to insertAfter.
         */
        public void insertAfterEntryNode(Node node) {
            if (node != null) {
                NodeSequence children = entryPaneBuffer.removeContents();
                
                node.getParent().insertAfter(children, node);
            }
        }

        /**
         * Insert the caption buffer's root element after the stored caption node.
         */
        public void insertAfterEntryNode() {
            insertAfterEntryNode(insertAfterEntryNode);
        }

        /**
         * Insert the caption buffer's root element after the stored caption node.
         * @param node the node to insertAfter.
         */
        public void insertAfterCaptionNode(Node node) {
            if (node != null) {
                NodeSequence children = captionPaneBuffer.removeContents();
                
                node.getParent().insertAfter(children, node);
            }
        }

        /**
         * Insert the caption buffer's root element after the stored caption node.
         */
        public void insertAfterCaptionNode() {
            insertAfterCaptionNode(insertAfterCaptionNode);
        }


    }

    //========================================================================
    // MenuModule related implementation.
    //========================================================================

    /**
     * Creates a default menu module for this protocol.
     */
    // Other javadoc inherited.
    protected MenuModule createMenuModule(
            MenuModuleRendererFactoryFilter metaFactory) {

        MenuModuleRendererFactory rendererFactory =
                new XHTMLBasicMenuModuleRendererFactory(getRendererContext(),
                        getDeprecatedOutputLocator(),
                        getMenuModuleCustomisation());

        if (metaFactory != null) {
            rendererFactory = metaFactory.decorate(rendererFactory);
        }

        return new DefaultMenuModule(getRendererContext(),
                rendererFactory);
    }

    protected PropertyHandler getCorrectWidthHandler(Element element) {
        PropertyHandler widthHandler;
        if (element.getName().equals("table")) {
            widthHandler = tableWidthHandler;
        } else {
            widthHandler = this.widthHandler;
        }
        return widthHandler;
    }

    public OutputBufferWriter getDirectWriter() {
        if (directWriter == null) {
            directWriter = new ProtocolWriter(this, true);
        }
        return directWriter;
    }
    
    /**
     * Registers form field attributes, which can be accessed later accessed by
     * its ID.
     * 
     * @param attributes The attributes to register.
     */
    private void registerFormFieldAttributes(XFFormFieldAttributes attributes) {
        String id = attributes.getId();
        
        if (id != null) {
            if (formFieldRegistryMap == null) {
                formFieldRegistryMap = new HashMap();
            }
            
            formFieldRegistryMap.put(id, attributes);
        }
    }
    
    /**
     * Retrieves form field attributes for specified ID.
     * 
     * @param id The ID if the attributes.
     * @return The form field attributes.
     */
    public XFFormFieldAttributes getFormFieldAttributes(String id) {
        XFFormFieldAttributes attributes = null;
        
        if (formFieldRegistryMap != null) {
            attributes = (XFFormFieldAttributes)formFieldRegistryMap.get(id);
        }
        
        return attributes;
    }
}

/*
 ===========================================================================
 Change History
 ===========================================================================
 $Log$

 14-Dec-05	10799/1	geoff	VBM:2005081506 Port 2005071314 forward to MCS

 07-Dec-05	10321/4	emma	VBM:2005103109 Supermerge required

 15-Nov-05	10321/1	emma	VBM:2005103109 Forward port: Styling not applied correctly to some xf selectors

 14-Nov-05	10300/1	emma	VBM:2005103109 Styling not applied correctly to some xf selectors

 06-Dec-05	10641/1	geoff	VBM:2005113024 Pagination page rendering issues

 06-Dec-05	10621/1	geoff	VBM:2005113024 Pagination page rendering issues

 29-Nov-05	10505/7	pduffin	VBM:2005111405 Committing transactions from MCS 3.5.0 (7)

 29-Nov-05	10347/5	pduffin	VBM:2005111405 Massive changes for performance

 29-Nov-05	10505/3	pduffin	VBM:2005111405 Committing transactions from MCS 3.5.0 (6)

 21-Nov-05	10347/1	pduffin	VBM:2005111405 Cleaned up PropertyValues to remove synthesised properties and moved specified into an extended interface

 25-Nov-05	10453/1	rgreenall	VBM:2005092107 Restrict the length of lines written by MCS for devices that have a maximum line limit.

 25-Nov-05	9708/5	rgreenall	VBM:2005092107 Restrict the length of lines written by MCS for devices that have a maximum line limit.

 08-Aug-05	9205/1	rgreenall	VBM:2005062107 Forward port of VBM:2005062107

 09-Nov-05	10201/1	emma	VBM:2005102606 Fixing various styling bugs

 07-Nov-05	10096/3	ianw	VBM:2005101918 Change rendering of mcs-rows to use correct styling, also fix ClassCastException in AssetGroups

 07-Nov-05	10096/1	ianw	VBM:2005101918 Change rendering of mcs-rows to use correct styling, also fix ClassCastException in AssetGroups

 02-Nov-05	10048/3	ibush	VBM:2005081219 Horizontal Rule Emulation

 01-Nov-05	9565/10	ibush	VBM:2005081219 Horizontal Rule Emulation

 01-Nov-05	9565/8	ibush	VBM:2005081219 Horizontal Rule Emulation

 31-Oct-05	9565/6	ibush	VBM:2005081219 Horizontal Rule Emulation

 27-Oct-05	9565/3	ibush	VBM:2005081219 Horizontal Rule Emulation

 24-Oct-05	9565/1	ibush	VBM:2005081219 Horizontal Rule Emulation
 09-Nov-05	10201/1	emma	VBM:2005102606 Fixing various styling bugs

 07-Nov-05	10096/3	ianw	VBM:2005101918 Change rendering of mcs-rows to use correct styling, also fix ClassCastException in AssetGroups

 07-Nov-05	10096/1	ianw	VBM:2005101918 Change rendering of mcs-rows to use correct styling, also fix ClassCastException in AssetGroups

 02-Nov-05	10048/3	ibush	VBM:2005081219 Horizontal Rule Emulation

 01-Nov-05	9565/10	ibush	VBM:2005081219 Horizontal Rule Emulation

 01-Nov-05	9565/8	ibush	VBM:2005081219 Horizontal Rule Emulation

 31-Oct-05	9565/6	ibush	VBM:2005081219 Horizontal Rule Emulation

 27-Oct-05	9565/3	ibush	VBM:2005081219 Horizontal Rule Emulation

 24-Oct-05	9565/1	ibush	VBM:2005081219 Horizontal Rule Emulation

 28-Oct-05	10020/1	geoff	VBM:2005102406 Height attributes incorrectly rendered

 25-Nov-05	9708/5	rgreenall	VBM:2005092107 Restrict the length of lines written by MCS for devices that have a maximum line limit.

 08-Aug-05	9205/1	rgreenall	VBM:2005062107 Forward port of VBM:2005062107

 09-Nov-05	10221/1	emma	VBM:2005102606 Forward port: fixing various styling bugs

 09-Nov-05	10201/1	emma	VBM:2005102606 Fixing various styling bugs

 07-Nov-05	10126/1	ianw	VBM:2005101918 Change rendering of mcs-rows to use correct styling, also fix ClassCastException in AssetGroups

 07-Nov-05	10096/3	ianw	VBM:2005101918 Change rendering of mcs-rows to use correct styling, also fix ClassCastException in AssetGroups

 07-Nov-05	10096/1	ianw	VBM:2005101918 Change rendering of mcs-rows to use correct styling, also fix ClassCastException in AssetGroups

 01-Nov-05	9565/10	ibush	VBM:2005081219 Horizontal Rule Emulation

 01-Nov-05	9565/8	ibush	VBM:2005081219 Horizontal Rule Emulation

 31-Oct-05	9565/6	ibush	VBM:2005081219 Horizontal Rule Emulation

 27-Oct-05	9565/3	ibush	VBM:2005081219 Horizontal Rule Emulation

 24-Oct-05	9565/1	ibush	VBM:2005081219 Horizontal Rule Emulation

 28-Oct-05	10020/1	geoff	VBM:2005102406 Height attributes incorrectly rendered

 10-Oct-05	9673/1	pduffin	VBM:2005092906 Improved validation and fixed layout formatting

 02-Oct-05	9637/7	emma	VBM:2005092807 XForms in XDIME-CP (without tests)

 30-Sep-05	9637/3	emma	VBM:2005092807 XForms in XDIME-CP (without tests)

 21-Sep-05	9128/10	pabbott	VBM:2005071114 Review feedback for XHTML2 elements

 20-Sep-05	9128/6	pabbott	VBM:2005071114 Add XHTML 2 elements

 19-Sep-05	9472/9	ibush	VBM:2005090808 Add default styling for sub/sup elements

 14-Sep-05	9472/6	ibush	VBM:2005090808 Add default styling for sub/sup elements

 09-Sep-05	9472/3	ibush	VBM:2005090808 Add default styling for sub/sup elements

 09-Sep-05	9472/1	ibush	VBM:2005090808 Add default styling for sub/sup elements

 15-Sep-05	9524/1	emma	VBM:2005091503 Added ContainerInstance to allow regions and panes to be treated in the same way

 02-Sep-05	9407/2	pduffin	VBM:2005083007 Committing resolved conflicts

 01-Sep-05	9375/2	geoff	VBM:2005082301 XDIMECP: clean up protocol creation

 30-Aug-05	9353/6	pduffin	VBM:2005081912 Removed style class from MCS Attributes

 25-Aug-05	9370/3	gkoch	VBM:2005070507 xform select option to store caption styles instead of caption (style) class

 22-Aug-05	9363/5	emma	VBM:2005080405 Remove the 'supports multi class' properties

 22-Aug-05	9363/2	emma	VBM:2005080405 Remove the 'supports multi class' properties

 22-Aug-05	9298/5	geoff	VBM:2005080402 Style portlets and inclusions correctly.

 22-Aug-05	9324/4	ianw	VBM:2005080202 Move validation for WapCSS into styling

 19-Aug-05	9289/3	emma	VBM:2005081602 Refactoring UnabridgedTransformers so they're not singletons

 18-Aug-05	9007/2	pduffin	VBM:2005071209 Committing massive changes to the product to improve styling, specifically for layouts

 04-Aug-05	9151/1	pduffin	VBM:2005080205 Removing a lot of unnecessary styling code

 22-Jul-05	9110/1	pduffin	VBM:2005072107 First stab at integrating new themes stuff together

 23-Jun-05	8833/3	pduffin	VBM:2005042901 Addressing review comments

 21-Jun-05	8833/1	pduffin	VBM:2005042901 Merged changes from MCS 3.3.1, improved testability of the protocols

 09-Jun-05	8665/7	emma	VBM:2005060204 Refactoring in order to annotate DOM with style info, some tests commented out temporarily

 09-Jun-05	8665/2	emma	VBM:2005060204 Refactoring in order to annotate DOM with style info

 02-Jun-05	8005/4	pduffin	VBM:2005050404 Moved dom to its own subsystem

 05-May-05	8005/1	pduffin	VBM:2005050404 Separated DOM from within runtime into its own subsystem, move concrete DOM objects out of API, replaced with interfaces and factories, removed pooling

 24-May-05	8123/4	ianw	VBM:2005050906 Fix merge conflicts

 11-May-05	8123/1	ianw	VBM:2005050906 Refactored DeviceTheme to seperat out CSSEmulator

 24-May-05	8462/1	philws	VBM:2005052310 Port device access key override from 3.3

 24-May-05	8430/1	philws	VBM:2005052310 Allow the device to override a protocol's access key support

 22-Apr-05	7820/1	philws	VBM:2005040411 Port submit button fix from 3.3

 22-Apr-05	7812/1	philws	VBM:2005040411 Ensure submit action is retained if action style is image but no image can be found

 05-Apr-05	7513/1	geoff	VBM:2003100606 DOMOutputBuffer allows creation of text which renders incorrectly in WML

 15-Mar-05	7404/1	philws	VBM:2005031006 Port portlet style class fix from 3.3

 15-Mar-05	7392/1	philws	VBM:2005031006 Fix portlet inclusion style generation in XHTML protocols

 11-Mar-05	7308/4	tom	VBM:2005030702 Added XHTMLSmartClient and support for image sequences

 11-Mar-05	7308/2	tom	VBM:2005030702 Added XHTMLSmartClient and support for image sequences

 09-Mar-05	7022/2	geoff	VBM:2005021711 R821: Branding using Projects: Prerequisites: Fix menu expression resolution

 17-Feb-05	6957/2	geoff	VBM:2005021103 R821: Branding using Projects: Prerequisites: use current project in PAPI phase

 11-Feb-05	6931/2	geoff	VBM:2005020901 R821: Branding using Projects: Prerequisites: Fix remaining manual id creation

 03-Mar-05	7277/1	philws	VBM:2005011906 Port pane styling fix from MCS 3.3

 03-Mar-05	7273/1	philws	VBM:2005011906 Ensure panes are thematically styled as per the requesting XDIME style class specifications

 24-Feb-05	7129/1	philws	VBM:2005011701 Ensure logger info, warn and error calls are localizable

 24-Feb-05	7099/1	philws	VBM:2005011701 Ensure logger info, warn and error calls are localizable

 16-Feb-05	6129/9	matthew	VBM:2004102019 yet another supermerge

 16-Feb-05	6129/7	matthew	VBM:2004102019 yet another supermerge

 27-Jan-05	6129/5	matthew	VBM:2004102019 supermerge required

 23-Nov-04	6129/2	matthew	VBM:2004102019 Enable shortcut menu link rendering

 09-Dec-04	6417/1	philws	VBM:2004120703 Committing tidy up

 08-Dec-04	6416/3	ianw	VBM:2004120703 New Build

 08-Dec-04	6232/7	doug	VBM:2004111702 refactored logging framework

 29-Nov-04	6332/1	doug	VBM:2004112913 Refactored logging framework

 29-Nov-04	6232/5	doug	VBM:2004111702 Refactored Logging framework

 26-Nov-04	6076/4	tom	VBM:2004101509 Modified protocols to get their styles from MCSAttributes

 22-Nov-04	5733/11	geoff	VBM:2004093001 Support OMA WCSS subset of CSS2

 22-Nov-04	5733/9	geoff	VBM:2004093001 Support OMA WCSS subset of CSS2

 19-Nov-04	5733/6	geoff	VBM:2004093001 Support OMA WCSS subset of CSS2

 19-Nov-04	6253/1	claire	VBM:2004111704 mergevbm: Handle portal themes correctly and remove caching of themes and emulation in protocols

 19-Nov-04	6236/1	claire	VBM:2004111704 Handle portal themes correctly and remove caching of themes and emulation in protocols

 18-Nov-04	6135/4	byron	VBM:2004081726 Allow spatial format iterators within forms

 12-Nov-04	6135/2	byron	VBM:2004081726 Allow spatial format iterators within forms

 01-Nov-04	6068/1	tom	VBM:2004101508 renamed VolantisAttribute to MCSAttributes and added style properties container

 19-Oct-04	5816/2	byron	VBM:2004101318 Support style classes: Runtime XHTMLBasic

 12-Oct-04	5778/2	adrianj	VBM:2004083106 Provide styling engine API

 11-Oct-04	5744/1	claire	VBM:2004092801 mergevbm: Encoding of style class names for inclusions

 11-Oct-04	5742/1	claire	VBM:2004092801 Encoding of style class names for inclusions

 07-Oct-04	5729/3	claire	VBM:2004092801 Encoding of style class names for inclusions

 06-Sep-04	5361/7	pcameron	VBM:2004082517 New subprotocol for SE P800/P900 devices which adds cellspacing=0 to all tables

 01-Sep-04	5331/1	pcameron	VBM:2004082517 New subprotocol for SE P800/P900 devices to add cellspacing=0 to all tables

 13-Aug-04	5220/1	pcameron	VBM:2004081303 Fixed HTML3.2 inclusions with a hack

 13-Aug-04	5204/4	pcameron	VBM:2004081303 Fixed HTML3.2 inclusions with a hack

 13-Aug-04	5204/4	pcameron	VBM:2004081303 Fixed HTML3.2 inclusions with a hack

 01-Jul-04	4778/2	allan	VBM:2004062912 Use the Volantis.pageURLRewriter to rewrite page urls

 28-Jun-04	4685/1	steve	VBM:2004050406 Remove empty span around alt text

 28-Jun-04	4676/5	steve	VBM:2004050406 supermerged

 10-Jun-04	4676/2	steve	VBM:2004050406 Remove span from alt text

 08-Jun-04	4661/1	steve	VBM:2004060309 enable asset URL suffix attribute

 08-Jun-04	4643/2	steve	VBM:2004060309 enable asset URL suffix attribute

 01-Jun-04	4616/1	geoff	VBM:2004060103 Add proper support for protocol page debug outputter

 01-Jun-04	4614/1	geoff	VBM:2004060103 Add proper support for protocol page debug outputter

 17-May-04	4029/4	steve	VBM:2004042003 Supermerged again - Hurry up Mat :)

 26-Apr-04	4029/1	steve	VBM:2004042003 support hr element in netfront3 and MIB

 23-Apr-04	4020/1	steve	VBM:2004042003 support hr element in netfront3 and MIB

 14-May-04	4315/10	geoff	VBM:2004051204 Enhance Menu Support: WML Dissection: Integration

 13-May-04	4315/7	geoff	VBM:2004051204 Enhance Menu Support: WML Dissection: Integration

 13-May-04	4315/5	geoff	VBM:2004051204 Enhance Menu Support: WML Dissection: Integration

 13-May-04	4325/1	geoff	VBM:2004051208 Enhance Menu Support: WML Dissection: Menu Module Component Factory

 12-May-04	4315/1	geoff	VBM:2004051204 Enhance Menu Support: WML Dissection: Integration

 12-May-04	4279/3	pduffin	VBM:2004051104 Major refactoring to simplify extending the infrastructure

 11-May-04	4217/1	geoff	VBM:2004042807 Enhance Menu Support: Renderers: Menu Markup

 06-May-04	4174/5	claire	VBM:2004050501 Enhanced Menus: (X)HTML menu renderer selectors and protocol integration

 06-May-04	4153/1	geoff	VBM:2004043005 Enhance Menu Support: Renderers: HTML Menu Item Renderers: refactoring

 26-Apr-04	3920/5	geoff	VBM:2004041910 Enhance Menu Support: Renderers: HTML Menu Item Renderers (review comments)

 26-Apr-04	3920/3	geoff	VBM:2004041910 Enhance Menu Support: Renderers: HTML Menu Item Renderers

 15-Apr-04	3884/1	claire	VBM:2004040712 Added AssetReferenceException

 23-Mar-04	3555/1	allan	VBM:2004032205 Patch performance fixes from MCS 3.0GA

 22-Mar-04	3512/1	allan	VBM:2004032205 MCS performance enhancements.

 15-Mar-04	3422/1	geoff	VBM:2004030907 name attribute not rendered on a tag

 15-Mar-04	3403/3	geoff	VBM:2004030907 name attribute not rendered on a tag

 12-Mar-04	3403/1	geoff	VBM:2004030907 name attribute not rendered on a tag

 08-Mar-04	3360/1	geoff	VBM:2004030502 onselect is not rendered on xfsiselect as radio button

 08-Mar-04	3358/1	geoff	VBM:2004030502 onselect is not rendered on xfsiselect as radio button

 05-Mar-04	3339/1	geoff	VBM:2003052104 Invalid usage of DOMOutputBuffer.appendLiteral()

 05-Mar-04	3337/1	geoff	VBM:2003052104 Invalid usage of DOMOutputBuffer.appendLiteral()

 05-Mar-04	3323/1	geoff	VBM:2003052104 Invalid usage of DOMOutputBuffer.appendLiteral()

 01-Mar-04	3148/4	geoff	VBM:2003121501 XHTML basic throws exception when using dissecting panes (supermerge)

 19-Feb-04	3148/1	geoff	VBM:2003121501 XHTML basic throws exception when using dissecting panes

 19-Feb-04	3138/1	geoff	VBM:2003121501 XHTML basic throws exception when using dissecting panes

 26-Feb-04	3233/2	geoff	VBM:2004021609 styleclasses incorrectly rendered when within a region

 25-Feb-04	3179/4	geoff	VBM:2004021609 styleclasses incorrectly rendered when within a region

 24-Feb-04	3179/2	geoff	VBM:2004021609 styleclasses incorrectly rendered when within a region

 25-Feb-04	2974/5	steve	VBM:2004020608 supermerged

 17-Feb-04	2974/2	steve	VBM:2004020608 SGML Quote handling

 19-Feb-04	2789/4	tony	VBM:2004012601 refactored localised logging to synergetics

 12-Feb-04	2789/2	tony	VBM:2004012601 Localised logging (and exceptions)

 12-Feb-04	2958/2	philws	VBM:2004012715 Add protocol.content.type device policy

 16-Dec-03	2075/4	mat	VBM:2003120106 Fixed merge conflicts

 05-Dec-03	2075/1	mat	VBM:2003120106 Rename Device and add a public Device Interface

 08-Dec-03	2169/1	steve	VBM:2003120506 native markup html.head output patched from Proteus

 08-Dec-03	2164/1	steve	VBM:2003120506 html.head support

 17-Nov-03	1749/4	philws	VBM:2003081102 Fix merge issues

 01-Nov-03	1749/1	philws	VBM:2003081102 Port of Spatial and Temporal Iterator layout stylesheet handling from PROTEUS

 01-Nov-03	1745/1	philws	VBM:2003081102 Provide layout style for Spatial and Temporal Iterators

 12-Nov-03	1861/1	mat	VBM:2003110602 Added presentation markup to XHTMLMobile1_0 and corrected mime types

 03-Nov-03	1760/1	philws	VBM:2003031710 Port image alt text component reference handling from PROTEUS

 02-Nov-03	1751/1	philws	VBM:2003031710 Permit image alt text to be component reference

 17-Sep-03	1412/5	geoff	VBM:2003091105 Modify WML Openwave protocols to render fragment links as numeric style links

 16-Sep-03	1301/8	byron	VBM:2003082107 Support Openwave GUI Browser extensions - single select controls handled as type=radio

 11-Sep-03	1301/5	byron	VBM:2003082107 Support Openwave GUI Browser extensions - resolved merge conflicts

 10-Sep-03	1301/2	byron	VBM:2003082107 Support Openwave GUI Browser extensions

 15-Sep-03	1321/7	adrian	VBM:2003082111 Fixed bug in wap-input-required styleproperty generation

 15-Sep-03	1321/5	adrian	VBM:2003082111 Fixed bug in wap-input-required styleproperty generation

 05-Sep-03	1321/2	adrian	VBM:2003082111 added wcss input validation for xhtmlmobile

 10-Sep-03	1386/1	philws	VBM:2003090801 (X)HTML support for native markup

 10-Sep-03	1379/1	philws	VBM:2003090801 (X)HTML support for native markup

 04-Sep-03	1015/8	geoff	VBM:2003072208 Style Class on spatial iterated pane not set on table cell in generated markup (supermerge)

 26-Aug-03	1015/5	geoff	VBM:2003072208 Style Class on spatial iterated pane not set on table cell in generated markup (supermerge fixes)

 08-Aug-03	1015/1	geoff	VBM:2003072208 merge from Mimas

 08-Aug-03	1011/1	geoff	VBM:2003072208 port from metis

 08-Aug-03	1004/1	geoff	VBM:2003072208 fix pane rendering in xhtml from netfront3

 02-Sep-03	1305/2	adrian	VBM:2003082108 added new openwave6 xhtml protocol

 21-Aug-03	1240/3	chrisw	VBM:2003070811 implemented rework

 21-Aug-03	1240/1	chrisw	VBM:2003070811 Ported emulation of CSS2 border-spacing from mimas to proteus

 21-Aug-03	1219/13	chrisw	VBM:2003070811 Ported emulation of CSS2 border-spacing from metis to mimas

 20-Aug-03	1152/1	chrisw	VBM:2003070811 Emulate CSS2 border-spacing using cellspacing on table element

 18-Aug-03	424/13	byron	VBM:2003022825 Task 580: Enhance behaviour of pane element within xfforms update

 15-Aug-03	424/9	byron	VBM:2003022825 Enhance behaviour of pane element within xfforms - bugfix

 17-Aug-03	1052/3	allan	VBM:2003073101 Support styles on menu and menuitems

 25-Jul-03	860/1	geoff	VBM:2003071405 merge from mimas

 25-Jul-03	858/1	geoff	VBM:2003071405 merge from metis; fix dissection test case sizes

 24-Jul-03	807/4	geoff	VBM:2003071405 now with fixed architecture

 23-Jul-03	807/2	geoff	VBM:2003071405 works and tested but no design review yet

 23-Jun-03	424/5	byron	VBM:2003022825 Fixed javadoc and variable naming

 20-Jun-03	424/3	byron	VBM:2003022825 Enhance behaviour of pane element within xfform

 19-Jun-03	429/1	philws	VBM:2003041605 Remove ClassCastException for spacial iterators in XHTMLBasic

 13-Jun-03	396/1	adrian	VBM:2003032708 fixed xfoption entry and caption pane fallback ordering

 12-Jun-03	381/1	mat	VBM:2003061101 Better debugging for WMLRoot

 05-Jun-03	285/7	mat	VBM:2003042911 Merged with MCS

 ===========================================================================
*/
