/*
This file is part of Volantis Mobility Server. 

Volantis Mobility Server is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Volantis Mobility Server is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Volantis Mobility Server.  If not, see <http://www.gnu.org/licenses/>. 
*/
/* ----------------------------------------------------------------------------
 * (c) Volantis Systems Ltd 2004. 
 * ----------------------------------------------------------------------------
 */
package com.volantis.mcs.eclipse.common.odom;

import com.volantis.mcs.xml.xpath.XPath;
import com.volantis.mcs.eclipse.common.odom.xpath.ODOMXPath;

import org.jdom.Attribute;
import org.jdom.Element;

import java.util.List;


/**
 * A hierarchy event (insertion or removal of a node) generated by an ODOM
 * change.
 * <p>
 * Carries as additional information the index that the changed node has after
 * insertion (or had before removal) as a content node for its parent.
 * </p>
 * <p>
 * This event is able to undo/redo an operation that :
 * <ol>
 *  <li> removes a child;</li>
 *  <li> attaches it to a foreign tree fragment (i.e, a fragment not part of
 *   the ODOM listened to for change events collected for undo/redo purposes);
 * </li>
 *  <li> then adds the entire fragment back to our (listened) odom.</li>
 *  </ol>
 *  But the result will only be correct under the assumption that the foreign
 *  tree fragment is truly unlistened to, e.g. no undos are explicitly done
 *  to it via another UndoRedoManager.
 * </p>
 * <p>
 * <strong>NOTE:</strong> the correct behavior of this class relies on a
 * Volantis-specific modification to JDOM, to allow access to the former
 * position of a removed content node.
 * </p>
 */
public class ODOMHierarchyChangeEvent extends ODOMChangeEvent {

    /**
     * Position of the source node in parent's content before removal or after
     * insertion.
     * <p>
     * If the event is an insertion, the normal <code>indexOf</code>method of
     * <code>java.util.List</code> calculates this index. If the event is a
     * removal, because this event object is created <em>after</em> the removal
     * action, this index is calculated using some special knowledge of the
     * Volantis-modified JDOM ContentList class.
     * <br>
     * Actually, the
     * modification of JDOM ContentList is hidden in the override of the
     * <code>indexOf()</code> method, that checks if it is invoked to look for
     * an element which has just been removed.
     * </p>
     * <p>
     * In the case of
     * 'batch' removals from a JDOM ContentList, all elements are removed one
     * after the other <em>from first to last</em>, this index is 0 (first
      * element) because undo will be performed in non-batch (iterating over the
     * events in anti-chronological order) by adding the removed element at the
     * <em>beginning</em> of the content.
     * </p>
     */
    protected int indexOfSourceAsContentOfParent;


    /**
     * Information needed for redo, only when undoing an operation that:
     * - removed a child,
     * - attached it to a foreign (unlistened to) tree fragment
     * - then added the entire fragment back to our (listened) odom
     * @see #undo()
     * @see #redo()
     */
    protected Element foreignParent;

    /**
     * @see #foreignParent
     */
    protected int indexOfSourceInForeignParent;


    /**
     * Initializes the new instance using the given parameters.
     *
     * @param source   the ODOMObservable (Element,Text,CData, Attribute) that
     *                 has been inserted or removed.
     * @param oldValue the ODOM Element parent of source prior to the change
     *                 happening or null for an addition of a child
     * @param newValue the ODOM Element parent of source after the change has
     *                 happened or null for a removal
     * @throws IllegalArgumentException if not exactly one between oldValue and
     *                                  newValue is null or if the removalIndex
     *                                  cannot be determined
     */
    public ODOMHierarchyChangeEvent(ODOMObservable source,
                                    Object oldValue,
                                    Object newValue) {
        super(source, oldValue, newValue, ChangeQualifier.HIERARCHY);

        //assertion
        if ((oldValue == null && newValue == null) ||
                (oldValue != null && newValue != null)) {
            throw new IllegalArgumentException(
                    "One and only one of the 'oldValue' and 'newValue' arguents must be null"); //$NON-NLS-1$
        }


        if ((source instanceof Attribute)) {
            // index irreleveant
        } else {
            //find the index as content
            Object parent = oldValue == null ? newValue : oldValue;

            if (parent instanceof Element) {
                List parentContent = ((Element) parent).getContent();
                /* ! relies on Volantis-overridden indexOf */
                indexOfSourceAsContentOfParent =
                        parentContent.indexOf(source);
            } else {
                //parent is Document - index is irrelevant
            }
        }
    }

    /**
     * @return true if this event was generated by a removal of an ODOMObservable
     */
    protected boolean isRemoval() {
        return getNewValue() == null;
    }


    // javadoc inherited
    public XPath undo() {
        if (this.isRemoval()) {
            ODOMElement oldParent = (ODOMElement) this.getOldValue();
            if (this.getSource() instanceof Attribute) {
                oldParent.getAttributes().add(this.getSource()); //index irrelevant
            } else {
                if (this.getSource() instanceof Element) {
                    Element elementSource = (Element) this.getSource();

                    foreignParent = elementSource.getParent();
                    if(foreignParent!=null) {
                        //the removed node was attached to an unlistened foreign odom fragment
                        //then need to save info for redo
                        indexOfSourceInForeignParent = foreignParent.getContent().indexOf(elementSource);
                        elementSource.detach();
                    }
                }

                oldParent.getContent().add(indexOfSourceAsContentOfParent,
                                           this.getSource());
            }

            return new ODOMXPath(getSource());

        } else {
            ODOMElement newParent = (ODOMElement) this.getNewValue();
            if (this.getSource() instanceof Attribute) {
                newParent.getAttributes().remove(this.getSource());
            } else {
                newParent.getContent().remove(this.getSource());
            }

            return null;
        }
    }


    // javadoc inherited
    public XPath redo() {
        if (this.isRemoval()) {
            ODOMElement oldParent = (ODOMElement) this.getOldValue();
            if (this.getSource() instanceof Attribute) {
                oldParent.getAttributes().remove(this.getSource());
            } else {
                oldParent.getContent().remove(this.getSource());

                if (foreignParent!=null) {
                    foreignParent.getContent().add(indexOfSourceInForeignParent,getSource());
                }
            }

            return null;

        } else {
            ODOMElement newParent = (ODOMElement) this.getNewValue();
            if (this.getSource() instanceof Attribute) {
                newParent.getAttributes().add(this.getSource()); //index irrelevant
            } else {
                // Since the standard element could be added in the
                // wrong order it may be that the redo tries to add it
                // before its sibling. In this case
                // indexOfSourceAsContentOfParent will be more than the
                // number of children and this will cause an
                // ArrayIndexOutOfBoundsException. The remedy is to
                // add the child at the childCount of the parent if
                // indexOfSourceAsContentOfParent is > childCount.
                int childCount = newParent.getContent().size();
                int index = indexOfSourceAsContentOfParent <= childCount ?
                        indexOfSourceAsContentOfParent : childCount;
                newParent.getContent().add(index, this.getSource());
            }

            return new ODOMXPath(getSource());
        }
    }
}


/*
 ===========================================================================
 Change History
 ===========================================================================
 $Log$

 11-Oct-05	9729/1	geoff	VBM:2005100507 Mariner Export fails with NPE

 21-Dec-04	6524/1	allan	VBM:2004112610 Move xpath and xml validation out of eclipse

 08-Dec-04	6416/3	ianw	VBM:2004120703 New Build

 08-Dec-04	6416/1	ianw	VBM:2004120703 New Build

 16-Nov-04	4394/3	allan	VBM:2004051018 Undo/Redo in device editor.

 16-Nov-04	4394/1	allan	VBM:2004051018 Undo/Redo in device editor.

 13-May-04	4301/3	byron	VBM:2004051018 CC/PP section does not handle undo/redo

 23-Mar-04	3362/1	steve	VBM:2003082208 Move API doclet to Synergetics and myriads of javadoc fixes

 09-Feb-04	2800/6	eduardo	VBM:2004012802 codestyle fixes

 09-Feb-04	2800/4	eduardo	VBM:2004012802 undo redo works from outline view

 05-Feb-04	2800/2	eduardo	VBM:2004012802 undo redo hooked in eclipse with demarcation. Designed just for single page editors

 03-Feb-04	2820/1	doug	VBM:2004013002 Used the eclipse 'externalize strings wizard' to identify language specific resources

 29-Jan-04	2689/5	eduardo	VBM:2003112407 formatting changes

 29-Jan-04	2689/3	eduardo	VBM:2003112407 undo/redo manager for ODOM

 ===========================================================================
*/
