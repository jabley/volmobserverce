/*
This file is part of Volantis Mobility Server. 

Volantis Mobility Server is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Volantis Mobility Server is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Volantis Mobility Server.  If not, see <http://www.gnu.org/licenses/>. 
*/
/* ----------------------------------------------------------------------------
 * (c) Volantis Systems Ltd 2003. 
 * ----------------------------------------------------------------------------
 */

package com.volantis.mcs.xml.xpath;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.volantis.mcs.localization.LocalizationFactory;
import com.volantis.synergetics.log.LogDispatcher;
import org.jaxen.JaxenException;
import org.jaxen.SimpleNamespaceContext;
import org.jaxen.jdom.JDOMXPath;
import org.jdom.Attribute;
import org.jdom.CDATA;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.Text;
import org.jdom.filter.ContentFilter;
import org.jdom.filter.ElementFilter;
import org.jdom.filter.Filter;

/**
 * A set of ODOM XPath utilities are required that will allow, amongst other
 * things:
 *
 * <ul> <li>access to the string XPath representation required to
 * access a given (O/J)DOM element, attribute or text node either as an
 * absolute path in the document or relative to an ancestor (O/J)DOM
 * element.</li>
 *
 * <li>creation of the (O/J)DOM elements and attribute/text node
 * missing within a given (O/J)DOM hierarchy from a given absolute or relative
 * XPath string</li>
 *
 * <li>access to an existing (O/J)DOM element, attribute or
 * text node using an absolute or relative path within a given document/base
 * element.</li> </ul>
 */
public class XPath {

    /**
     * Used for logging
     */
    private static final LogDispatcher logger =
            LocalizationFactory.createLogger(XPath.class);

    /**
     * The XPath delimiter.
     */
    protected static final String XPATH_DELIM = "/";

    /**
     * The XPath text function.
     */
    protected static final String XPATH_TEXT_FUNCTION = "text()";

    /**
     * The XPath predicate start identifier.
     */
    protected static final String PREDICATE_START = "[";

    /**
     * The XPath predicate end identifier.
     */
    protected static final String PREDICATE_END = "]";

    /**
     * The XPath attribute identifier.
     */
    protected static final String ATTRIBUTE = "@";

    /**
     * The string representation of the XPath.
     */
    protected String xpath;

    /**
     * The jdom XPath that may be used to select nodes.
     */
    private JDOMXPath jdomXPath;

    /**
     * A map used to map a namespace prefix to the associated namespace
     * instance.
     */
    protected Map namespaceURIMap = new HashMap();

    /**
     * A default constructor for subclasses.
     */
    protected XPath() {
    }

    /**
     * Create an instance of this class with an XPath string.
     *
     * @param path the XPath, for example, '/catalog/cd'
     * @throws java.lang.IllegalArgumentException if the path is null or empty.
     */
    public XPath(String path)
            throws IllegalArgumentException {
        this(path, (String) null);
    }

    /**
     * Create an instance of this class with an XPath string.
     *
     * @param path       the XPath, for example, '/catalog/cd'
     * @param namespaces an array of namespaces that may be used to create
     *                   elements with the appropriate namespace.
     * @throws java.lang.IllegalArgumentException if the path is null or empty.
     */
    public XPath(String path, Namespace[] namespaces)
            throws IllegalArgumentException {

        if (path == null || path.length() == 0) {
            throw new IllegalArgumentException(
                    "Path parameter may not be null or empty.");
        }
        updateNamespaceMap(namespaces);
        this.xpath = path;
    }

    /**
     * Initializes the new instance using the given parameters.
     *
     * @param path              the XPath as a string, for example
     *                          '/catalog/cd'
     * @param encodedNamespaces a string containing encoded namespace
     *                          prefix/uri pairs as would be generated by
     *                          {@link #getNamespacesString}
     */
    public XPath(String path, String encodedNamespaces) {
        this(path, (Namespace[]) null);

        updateNamespaceMap(encodedNamespaces);
    }

    /**
     * Create an instance of this class with an XPath and relative string.
     *
     * @param xpath        an instance of an existing XPath object.
     * @param relativePath the XPath, for example, 'catalog/cd' which must not
     *                     start with a '/' character.
     * @throws java.lang.IllegalArgumentException if the relativePath is empty or starts
     *                                  with '/'.
     */
    public XPath(XPath xpath, String relativePath)
            throws IllegalArgumentException {

        this(xpath, relativePath, null);
    }

    /**
     * Create an instance of this class with an XPath and relative string and
     * additional namespaces.
     *
     * @param xpath                an instance of an existing XPath object, may
     *                             be null.
     * @param relativePath         the XPath, for example, 'catalog/cd' which
     *                             must not start with a '/' character.
     * @param additionalNamespaces an array of additionalNamespaces that may be
     *                             used to create elements with the appropriate
     *                             namespace.
     * @throws java.lang.IllegalArgumentException if the relativePath is empty or starts
     *                                  with '/'.
     */
    public XPath(XPath xpath, String relativePath, Namespace[] additionalNamespaces)
            throws IllegalArgumentException {

        Map namespaces = xpath == null ? null : xpath.namespaceURIMap;
        updateNamespaceMap(additionalNamespaces, namespaces);

        if (relativePath != null) {
            if ((relativePath.length() == 0) ||
                    relativePath.startsWith(XPATH_DELIM)) {
                throw new IllegalArgumentException(
                        "Relative path parameter may not be empty or start " +
                        "with a '" + XPATH_DELIM + "' character.");
            }

            if (xpath == null) {
                this.xpath = relativePath;
            } else {
                StringBuffer buffer = new StringBuffer(xpath.getExternalForm());
                buffer.append(XPATH_DELIM).append(relativePath);
                this.xpath = buffer.toString();
            }
        }
    }

    /**
     * Create an absolute XPath to this element.
     *
     * @param element the element that will be used to create the XPath.
     */
    public XPath(Element element) {
        this(null, element, null);
    }

    /**
     * Create an absolute XPath to this element.
     *
     * @param element              the element that will be used to create the
     *                             XPath.
     * @param additionalNamespaces an array of additionalNamespaces that may be
     *                             used to create elements with the appropriate
     *                             namespace.
     */
    public XPath(Element element, Namespace[] additionalNamespaces) {
        this(null, element, additionalNamespaces);
    }

    /**
     * Create an absolute XPath to the specified attribute.
     *
     * @param attribute the attribute that will be used to create the XPath.
     */
    public XPath(Attribute attribute) {
        this((Element) null, attribute, null);
    }

    /**
     * Create an absolute XPath to the specified attribute.
     *
     * @param attribute            the attribute that will be used to create the
     *                             XPath.
     * @param additionalNamespaces an array of additionalNamespaces that may be
     *                             used to create elements with the appropriate
     *                             namespace.
     */
    public XPath(Attribute attribute, Namespace[] additionalNamespaces) {
        this((Element) null, attribute, additionalNamespaces);
    }

    /**
     * Create an absolute XPath to the specified text node.
     *
     * @param text the text that will be used to create the XPath.
     */
    public XPath(Text text) {
        this(null, text, null);
    }

    /**
     * Create an absolute XPath to the specified text node.
     *
     * @param text                 the text that will be used to create the
     *                             XPath.
     * @param additionalNamespaces an array of additionalNamespaces that may be
     *                             used to create elements with the appropriate
     *                             namespace.
     */
    public XPath(Text text, Namespace[] additionalNamespaces) {
        this(null, text, additionalNamespaces);
    }

    /**
     * Create a relative or absolute XPath to the specified element. A
     * relative XPath will be created if start is not null.
     *
     * @param start   the start element.
     * @param element the end element that will be used to create the XPath.
     */
    public XPath(Element start, Element element) {
        this(start, element, null);
    }

    /**
     * Create a relative or absolute XPath to the specified element. A relative
     * XPath will be created if start is not null.
     *
     * @param start                the start element.
     * @param element              the end element that will be used to create
     *                             the XPath.
     * @param additionalNamespaces an array of additionalNamespaces that may be
     *                             used to create elements with the appropriate
     *                             namespace.
     */
    public XPath(Element start, Element element, Namespace[] additionalNamespaces) {
        xpath = createXPath(start, element, additionalNamespaces);
    }

    /**
     * Create a relative or absolute XPath to the specified attribute. A
     * relative XPath will be created if start is not null.
     *
     * @param start     the start element.
     * @param attribute the end element that will be used to create the XPath.
     */
    public XPath(Element start, Attribute attribute) {
        this(start, attribute, null);
    }

    /**
     * Create a relative or absolute XPath to the specified attribute. A
     * relative XPath will be created if start is not null.
     *
     * @param start                the start element.
     * @param attribute            the end element that will be used to create
     *                             the XPath.
     * @param additionalNamespaces an array of additionalNamespaces that may be
     *                             used to create elements with the appropriate
     *                             namespace.
     */
    public XPath(Element start, Attribute attribute, Namespace[] additionalNamespaces) {
        xpath = createXPath(start, attribute, additionalNamespaces);
    }

    /**
     * Create a relative XPath to the specified text node from the starting
     * element.
     *
     * @param start the start element.
     * @param text  the end text node that will be used to create the XPath.
     */
    public XPath(Element start, Text text) {
        this(start, text, null);
    }

    /**
     * Create a relative XPath to the specified text node from the starting
     * element.
     *
     * @param start                the start element.
     * @param text                 the end text node that will be used to create
     *                             the XPath.
     * @param additionalNamespaces an array of additionalNamespaces that may be
     *                             used to create elements with the appropriate
     *                             namespace.
     */
    public XPath(Element start, Text text, Namespace[] additionalNamespaces) {
        xpath = createXPath(start, text, additionalNamespaces);
    }

    /**
     * Create an instance of this class with an XPath and an attribute, where
     * the attribute is treated as a relative path containing only the
     * attribute's name. Effectively this just appends the attribute name to the
     * given XPath, using the appropriate syntax for an XPath component of type
     * attribute.
     *
     * @param xpath     an instance of an existing XPath object.
     * @param attribute the attribute to augment to the xpath in the way
     *                  described above. This may not be null.
     */
    public XPath(XPath xpath, Attribute attribute) {
        this(xpath, attribute, null);
    }

    /**
     * Create an instance of this class with an XPath and an attribute, where
     * the attribute is treated as a relative path containing only the
     * attribute's name. Effectively this just appends the attribute name to the
     * given XPath, using the appropriate syntax for an XPath component of type
     * attribute.
     *
     * @param xpath      an instance of an existing XPath object.
     * @param attribute  the attribute to augment to the xpath in the way
     *                   described above. This may not be null.
     * @param namespaces an array of namespaces that may be used to create
     *                   elements with the appropriate namespace.
     */
    public XPath(XPath xpath, Attribute attribute, Namespace[] namespaces) {
        Map namespaceMap = xpath == null ? null : xpath.namespaceURIMap;
        updateNamespaceMap(namespaces, namespaceMap);

        if (attribute != null) {
            if (attribute.getName() == null || attribute.getName().length() <= 0) {
                throw new IllegalArgumentException(
                        "Attribute name may not be null or empty.");
            }
            StringBuffer buffer = new StringBuffer();
            if (xpath != null) {
                buffer.append(xpath.getExternalForm()).append(XPATH_DELIM);

            }
            buffer.append(ATTRIBUTE).append(attribute.getName());
            this.xpath = buffer.toString();
        }
    }

    /**
     * Create an instance of this class with an XPath and a relative XPath.
     * Effectively this just appends the relative XPath to the given XPath.
     *
     * @param xpath         an instance of an existing XPath object.
     * @param relativeXPath the xpath to augment to the first xpath in the way
     *                      described above. This may not be null and must be
     *                      relative.
     * @throws java.lang.IllegalArgumentException if the specified relative xpath is not
     *                                  of correct syntax for a relative
     *                                  xpath.
     */
    public XPath(XPath xpath, XPath relativeXPath)
            throws IllegalArgumentException {

        this(xpath, relativeXPath, null);
    }

    /**
     * Create an instance of this class with an XPath and a relative XPath.
     * Effectively this just appends the relative XPath to the given XPath.
     *
     * @param xpath         an instance of an existing XPath object.
     * @param relativeXPath the xpath to augment to the first xpath in the way
     *                      described above. This may not be null and must be
     *                      relative.
     * @param namespaces    an array of namespaces that may be used to create
     *                      elements with the appropriate namespace.
     * @throws java.lang.IllegalArgumentException if the specified relative xpath is not
     *                                  of correct syntax for a relative xpath.
     */
    public XPath(XPath xpath, XPath relativeXPath, Namespace[] namespaces)
            throws IllegalArgumentException {

        this(xpath, (relativeXPath == null ? (String) null :
                relativeXPath.getExternalForm()), namespaces);
    }

    /**
     * Create a relative XPath to the specified element from the starting
     * element.
     *
     * @param start                the start element.
     * @param element              the end element that will be used to create
     *                             the XPath.
     * @param additionalNamespaces an array of additionalNamespaces that may be
     *                             used to create elements with the appropriate
     *                             namespace.
     * @return a relative XPath to the specified element from the starting
     *         element.
     */
    protected String createXPath(Element start,
                                 Element element,
                                 Namespace[] additionalNamespaces) {

        if (element == null) {
            throw new IllegalArgumentException(
                    "Parameter 'element' cannot be null.");
        }
        updateNamespaceMap(additionalNamespaces, start, element);

        StringBuffer path = new StringBuffer();
        if ((start == element) ||
                (!constructPathToElement(start, element, path))) {
            path.append('.');
        }
        return path.toString();
    }

    /**
     * Create a relative XPath to the specified attribute from the starting
     * element.
     *
     * @param start                the start element.
     * @param attribute            the end element that will be used to create
     *                             the XPath.
     * @param additionalNamespaces an array of additionalNamespaces that may be
     *                             used to create elements with the appropriate
     *                             namespace.
     * @return a relative XPath to the specified element from the starting
     *         element.
     * @throws java.lang.IllegalArgumentException if the attribute parameter may not be
     *                                  null.
     */
    protected String createXPath(Element start,
                                 Attribute attribute,
                                 Namespace[] additionalNamespaces)
            throws IllegalArgumentException {

        if (attribute == null) {
            throw new IllegalArgumentException(
                    "Attribute parameter may not be null.");
        }
        if (attribute.getParent() == null) {
            throw new IllegalArgumentException("Attribute node must have a parent.");
        }

        updateNamespaceMap(additionalNamespaces, start, attribute.getParent());

        Element parent = attribute.getParent();
        StringBuffer path = new StringBuffer();

        if (constructPathToElement(start, parent, path)) {
            path.append(XPATH_DELIM);
        }

        path.append(ATTRIBUTE).append(attribute.getName());
        return path.toString();
    }

    /**
     * Create an absolute or relative XPath to the specified text node from the
     * starting element. A relative XPath will be created if start is not null.
     *
     * @param start                the start element.
     * @param text                 the end text node that will be used to create
     *                             the XPath.
     * @param additionalNamespaces an array of additionalNamespaces that may be
     *                             used to create elements with the appropriate
     *                             namespace.
     * @return a relative XPath to the specified text node from the starting
     *         element.
     */
    protected String createXPath(Element start,
                                 Text text,
                                 Namespace[] additionalNamespaces) {
        if (text == null) {
            throw new IllegalArgumentException(
                    "Text parameter may not be null."); //$NON-NLS-1$
        }
        if (text.getParent() == null) {
            throw new IllegalArgumentException("Text node must have a parent."); //$NON-NLS-1$
        }
        updateNamespaceMap(additionalNamespaces, start, text.getParent());

        Element parent = text.getParent();

        int size = 0;
        int index = 0;
        if (parent != null) {
            Filter filter = new ContentFilter(ContentFilter.TEXT);
            List content = parent.getContent(filter);
            size = content.size();
            index = content.indexOf(text);
        }
        StringBuffer path = new StringBuffer();

        if (constructPathToElement(start, parent, path)) {
            path.append(XPATH_DELIM);
        }
        path.append(XPATH_TEXT_FUNCTION);

        if (size > 1) {
            path.append(PREDICATE_START).append(index + 1).append(PREDICATE_END);
        }
        return path.toString();
    }

    /**
     * Recursively construct the path to the element. If the start element is
     * null, then the path will be relative.
     *
     * @param start   the start element
     * @param element the element to construct the path to.
     * @param path    the path that will be used to store the results of the
     *                construction.
     * @return true if the result requires a '/' or '.' to be appended.
     */
    protected boolean constructPathToElement(Element start,
                                             Element element,
                                             StringBuffer path) {
        boolean requiresAppending = false;

        if (element == null) {
            path.append(XPATH_DELIM);
            requiresAppending = false;
        } else if (element == start) {
            // do nothing and return false
        } else {
            Element parent = element.getParent();
            int size = 1;
            int index = 0;

            if (parent != null) {
                Filter filter = new ElementFilter(element.getName());
                List elements = parent.getContent(filter);
                size = elements.size();
                index = elements.indexOf(element);
            }

            if (requiresAppending = constructPathToElement(start, parent, path)) {
                path.append(XPATH_DELIM);
            }

            Namespace namespace = element.getNamespace();
            if (namespace != null && namespace.getPrefix().length() > 0) {
                path.append(namespace.getPrefix()).append(":");
            }
            path.append(element.getName());

            if (size > 1) {
                path.append(PREDICATE_START).append(index + 1);
                path.append(PREDICATE_END);
            }
            requiresAppending = true;
        }
        return requiresAppending;
    }

    /**
     * Evaluates the wrapped XPath expression and returns the first entry in
     * the list of selected nodes.
     *
     * @param context the node to use as context for evaluating the XPath
     *                expression. It must be an instance of one of the following
     *                ODOM/JDOM classes: ODOM/Element, ODOM/Attribute,
     *                ODOM/Text, ODOM/CDATA
     * @return the first selected nodes, which is an instance of one of the
     *         following ODOM/JDOM classes: ODOM/Element, ODOM/Attribute,
     *         ODOM/Text, ODOM/CDATA, Comment or ProcessingInstruction or null
     *         if no node was selected.
     * @exception com.volantis.mcs.xml.xpath.XPathException if a Jaxen exception is raised.
     */
    public Object selectSingleNode(Object context)
            throws XPathException {
        Object result = null;
        try {
            if (jdomXPath == null) {
                jdomXPath = createJDOMXPath();
            }
            result = jdomXPath.selectSingleNode(context);
        } catch (JaxenException e) {
            throw new XPathException(e);
        }
        return result;
    }

    /**
     * Evaluates this XPath expression using the context parameter as the
     * XPaths context. If the selected node is not an {@link org.jdom.Element} an {@link
     * XPathException} is thrown, otherwise the Element is returned
     *
     * @param context the Element to use as the context for evaluating this
     *                XPath
     * @return the Element the selected element, or null if no element
     * could be selected
     * @throws com.volantis.mcs.xml.xpath.XPathException if the selected node is not an Element instance.
     * @todo later refactor this to behave as getElement and remove getElement
     */
    public Element selectSingleElement(Element context) throws XPathException {
        Element result = null;
        try {
            if (jdomXPath == null) {
                jdomXPath = createJDOMXPath();
            }
            Object node = jdomXPath.selectSingleNode(context);
            if (node != null && !(node instanceof Element)) {
                throw new XPathException(
                        "Expected instance of element but was " +
                        node.getClass().getName());
            }
            result = (Element) node;
        } catch (JaxenException e) {
            throw new XPathException(e);
        }
        return result;
    }

    /**
     * Override equals to use the external form for equality. Note that
     * this method uses instanceof for equality so that logically equal
     * sub-classes will be equal to this class. This is why equals() is
     * final. If a sub-class requires a different equals then either the
     * sub-class should not be a sub-class or this equals will need to be
     * modified. Modifying this equals() method could be problematic since
     * XPath is used in Collections and there is no guarantee that all
     * usages of XPath within Collections that implicitly utilize equals()
     * are unit tested. Even so it probably would mean resorting to Maps
     * instead of Lists or Sets in every occasion and using the
     * external form as the key for the equality test - or alternatively
     * Comparator that does the required kind of equality test where equals()
     * may be used for example within a Collection. Searching for all usages
     * of XPath within Collections is a highly manual task and it is in
     * any case difficult to prevent future usages of XPath within Collections
     * where equals() might be called.
     *
     * The method externalFormsEqual() should be used in preference to this
     * method i.e. it is better to not call this method explicitly.
     *
     * @return true if the given Object is logically equal to this XPath.
     */
    public final boolean equals(Object o) {
        boolean equals = o != null && o instanceof XPath;
        if (equals) {
            equals = getExternalForm().equals(((XPath) o).getExternalForm());
        }

        return equals;
    }

    /**
     * Override hashCode. See {@link #equals(Object)}.
     * @return the hashCode for this XPath.
     */
    public final int hashCode() {
        return getExternalForm().hashCode() + XPath.class.hashCode();
    }

    /**
     * Get the most specific Element specified by this XPath within a given
     * context. If this XPath points to a node other than an Element then
     * the returned Element will be the parent of the node.
     * @param context the Element to use as the context for evaluating this
     * XPath
     * @return the most specific Element specified by this XPath within the
     * given context or null if no Element was found within the given context
     */
    public Element getElement(Element context) throws XPathException {
        Element result = null;
        try {
            if (jdomXPath == null) {
                jdomXPath = createJDOMXPath();
            }
            Object node = jdomXPath.selectSingleNode(context);
            if (node != null && node instanceof Attribute) {
                node = ((Attribute) node).getParent();
            } else if (node != null && node instanceof Text) {
                node = ((Text) node).getParent();
            } else if (node != null && node instanceof CDATA) {
                node = ((CDATA) node).getParent();
            }
            result = (Element) node;
        } catch (JaxenException e) {
            throw new XPathException(e);
        }
        return result;
    }

    /**
     * Evaluates the wrapped XPath expression and returns the list of selected
     * nodes.
     *
     * @param context the node to use as context for evaluating the XPath
     *                expression.
     * @return the list of selected nodes, which can be instances of the
     *         following JDOM classes: Element, Attribute,
     *         Text, CDATA, Comment or ProcessingInstruction
     * @throws com.volantis.mcs.xml.xpath.XPathException if a Jaxen Exception occurred.
     */
    public List selectNodes(Object context) throws XPathException {
        List result = null;
        try {
            if (jdomXPath == null) {
                jdomXPath = createJDOMXPath();
            }
            result = jdomXPath.selectNodes(context);
        } catch (JaxenException e) {
            throw new XPathException(e);
        }
        return result;
    }

    /**
     * Creates a {@link org.jaxen.jdom.JDOMXPath} instance that represents this
     * XPath. The JDOMXPath object is made aware of all the Namespaces
     * associated with this xpath
     * @return a JDOMXPath instance
     * @throws org.jaxen.JaxenException if an error occurs.
     */
    private JDOMXPath createJDOMXPath() throws JaxenException {
        // create a JDOMXPath instance
        JDOMXPath jXPath = new JDOMXPath(xpath);
        if (namespaceURIMap != null) {
            // we need to ensure that the JDOMXPath knows about the
            // namespaces associated with this xpath. We can do this
            // be wrapping the namespaceURI map in a SimpleNamespaceContext
            // implementation and registering this with the JDOMXPath instance.
            jXPath.setNamespaceContext(
                    new SimpleNamespaceContext(namespaceURIMap));
        }
        return jXPath;
    }

    /**
     * Returns the XPath String that represents the parent of the node that
     * this XPath refers to. For example if this XPath has an external form of
     * "/a/b" the returned value will be "/a".
     *
     * @return the XPath String that is the parent of this path or null if this
     *         path does not have a parent
     */
    public String getParentStr() {
        int delimIndex = xpath.lastIndexOf(XPATH_DELIM);
        String parent = null;
        if (delimIndex != -1 && delimIndex != 0) {
            parent = xpath.substring(0, delimIndex);
        }
        return parent;
    }

    /**
     * Returns the XPath that represents the parent of the node that this XPath
     * refers to. For example if this XPath refers to the node <dfn>/a/b</dfn>
     * the parent XPath will be <dfn>/a</dfn>.
     *
     * @return the XPath that is the parent of this path or null if this path
     *         does not have a parent
     */
    public XPath getParent() {
        XPath parent = null;
        String parentStr = getParentStr();
        if (parentStr != null) {
            parent = new XPath(parentStr);
            // XPath instances are immutable so it is ok to share the same
            // namespace map.
            parent.namespaceURIMap = namespaceURIMap;
        }
        return parent;
    }

    /**
     * Overriding of the standard equals method.
     *
     * @param xPath the object used to compare this object to.
     * @return true if and only if the supplied object is an instance of this
     *         class and its external form is equal to this instance's external
     *         form.
     */
    public boolean externalFormsEqual(XPath xPath) {
        return xPath != null &&
                getExternalForm().equals(xPath.getExternalForm());
    }

    /**
     * Return the external form of this XPath.
     *
     * @return the external form of this XPath.
     */
    public String getExternalForm() {
        return xpath;
    }

    /**
     * Provide the DOMType that this XPath points to.
     * @return the DOMType of this XPath.
     */
    public DOMType getDOMType() {
        DOMType domType = null;
        if (xpath.indexOf(ATTRIBUTE) != -1) {
            domType = DOMType.ATTRIBUTE_TYPE;
        } else if (xpath.indexOf(XPATH_TEXT_FUNCTION) != -1) {
            domType = DOMType.TEXT_TYPE;
        } else {
            domType = DOMType.ELEMENT_TYPE;
        }

        return domType;
    }

    /**
     * Returns a string encoding the namespace prefixes and URIs associated
     * with this XPath.
     *
     * <p><strong>NOTE</strong>: This implementation currently will throw a
     * runtime exception if invoked on an XPath with one or more namespace
     * where the URI contains a space. This restriction could be lifted in
     * future by escaping or encoding spaces in the URIs. The {@link
     * #updateNamespaceMap(String)} implementation must match this
     * implementation.</p>
     *
     * @return a string encoding the namespace prefixes and URIs associated
     *         with this XPath
     */
    public String getNamespacesString() {
        StringBuffer result = new StringBuffer(80 * namespaceURIMap.size());
        Iterator i = namespaceURIMap.keySet().iterator();
        boolean next = false;
        String prefix;
        String uri;

        while (i.hasNext()) {
            prefix = (String) i.next();
            uri = (String) namespaceURIMap.get(prefix);

            if (uri.indexOf(' ') != -1) {
                throw new IllegalArgumentException(
                        "A namespace string cannot be generated with " +
                        "spaces in one or more URI");
            }

            if (next) {
                result.append(' ');
            }

            next = true;

            result.append(prefix).append(':').append(uri);
        }

        return result.toString();
    }

    /**
     * Add the <code>Namespace</code> to the map.
     *
     * @param namespace the namespace to add to the map.
     */
    private void addNamespaceToMap(Namespace namespace) {
        if (namespace != null) {
            addNamespaceToMap(namespace.getPrefix(), namespace.getURI());
        }
    }

    private void addNamespaceToMap(String prefix, String uri) {
        if (prefix.length() > 0) {
            if (!namespaceURIMap.containsKey(prefix)) {
                // If the namespace map does not contain the key, then add
                // the new namespace to the map.
                namespaceURIMap.put(prefix, uri);
            } else {
                // The prefix is in the namespace map. Now check to see if the
                // uri value is different to the value we want to add. If it is
                // different, log an error message, otherwise ignore the value
                // (we don't want the map to contain duplicate namespaces).
                String URI = (String) namespaceURIMap.get(prefix);
                if ((uri == null) || !URI.equals(uri)) {
                    String msg = "A namespace with the prefix '" +
                            prefix + "' already exists with a " +
                            "different URI value of '" + uri + "'";
                    logError(msg);
                }
            }
        }
    }

    /**
     * Logs the error as an exception.
     *
     * @param msg the error to be logged
     */
    protected void logError(String msg) {
        logger.error(new IllegalStateException(msg));
    }

    /**
     * Update the namespace map with additional Namespace object and the
     * namespace(s) of the context and element <code>Element</code>s (if any).
     *
     * @param additionalNamespaces the array of namespace objects.
     * @param map                  a map of existing namespaces (prefix to
     *                             <code>Namespace</code> object.
     */
    private void updateNamespaceMap(Namespace[] additionalNamespaces, Map map) {
        updateNamespaceMap(additionalNamespaces);
        if (map != null) {
            Set keys = map.keySet();
            if (keys != null) {
                Iterator keyIterator = keys.iterator();
                while (keyIterator.hasNext()) {
                    final Object key = keyIterator.next();
                    addNamespaceToMap((String) key, (String) map.get(key));
                }
            }
        }
    }

    /**
     * Update the namespace map with additional Namespace object and the
     * namespace(s) of the context and element <code>Element</code>s (if any).
     *
     * @param additionalNamespaces the array of namespace objects.
     * @param context              an element which is ordinarily used as the
     *                             context (start).
     * @param element              an element which is used to construct an
     *                             XPath.
     */
    private void updateNamespaceMap(Namespace[] additionalNamespaces,
                                    Element context,
                                    Element element) {
        updateNamespaceMap(additionalNamespaces);

        if (context != null) {
            addNamespaceToMap(context.getNamespace());
        }

        //now add all namespaces found on the path until the root element
        while (element != null) {
            addNamespaceToMap(element.getNamespace());
            element = element.getParent();
        }
    }

    /**
     * Update the namespace map with the contents of the additionalNamespaces
     * array.
     *
     * @param additionalNamespaces the array of namespace objects.
     */
    private void updateNamespaceMap(Namespace[] additionalNamespaces) {
        if (additionalNamespaces != null) {
            if (namespaceURIMap == null) {
                namespaceURIMap = new HashMap(additionalNamespaces.length);
            }

            for (int i = 0; i < additionalNamespaces.length; i++) {
                Namespace namespace = additionalNamespaces[i];

                addNamespaceToMap(namespace);
            }
        }
    }

    /**
     * The additional namespaces provided in the encoded namespace prefix/URI
     * pairs string are added to the namespace map.
     *
     * <p><strong>NOTE</strong>: the <code>additionalNamespaces</code> must be
     * encoded in the form returned by {@link #getNamespacesString}.</p>
     *
     * @param additionalNamespaces the encoded namespace string containing the
     *                             namespaces to be added to this XPath's
     *                             namespace map
     */
    private void updateNamespaceMap(String additionalNamespaces) {
        if (additionalNamespaces != null) {
            int start = 0;
            int end;
            int delim;
            String prefix;
            String uri;

            if (namespaceURIMap == null) {
                namespaceURIMap = new HashMap();
            }

            // Iterate through the set of namespace prefix/uri pairs
            while (start < additionalNamespaces.length()) {
                // Identify the end of the current namespace prefix/uri pair
                end = additionalNamespaces.indexOf(' ', start);

                if (end == -1) {
                    end = additionalNamespaces.length();
                }

                // Identify the delimiter between the prefix and the uri
                delim = additionalNamespaces.indexOf(':', start);

                if ((delim == -1) ||
                        (delim >= end)) {
                    throw new IllegalArgumentException(
                            "The given encoded namespace string is invalid " +
                            "at or after index [" + start + "] (missing ':' " +
                            "separator between prefix and URI): \"" +
                            additionalNamespaces + "\"");
                } else {
                    // Add the current prefix/uri to the namespace map
                    prefix = additionalNamespaces.substring(start, delim);
                    uri = additionalNamespaces.substring(delim + 1, end);

                    addNamespaceToMap(prefix, uri);
                }

                // Move on to next namespace prefix/uri pair
                start = end + 1;
            }
        }
    }


    /**
     * Implementation for debugging purposes, with no
     * performance warranties.
     * @return a string representation for debugging purposes
     */
    public String toString() {
        return this.getExternalForm();
    }

    public static XPath createXPathInstance(Element start, Text text, Namespace[] additionalNamespaces) {
        return new XPath(start, text, additionalNamespaces);
    }
}

/*
 ===========================================================================
 Change History
 ===========================================================================
 $Log$

 24-Feb-05	7129/1	philws	VBM:2005011701 Ensure logger info, warn and error calls are localizable

 24-Feb-05	7099/1	philws	VBM:2005011701 Ensure logger info, warn and error calls are localizable

 21-Dec-04	6524/4	allan	VBM:2004112610 Move xpath and xml validation out of eclipse

 21-Dec-04	6524/2	allan	VBM:2004112610 Move xpath and xml validation out of eclipse

 08-Dec-04	6416/3	ianw	VBM:2004120703 New Build

 08-Dec-04	6416/1	ianw	VBM:2004120703 New Build

 10-Sep-04	5488/1	allan	VBM:2004081803 Fix TAC error messages and validate blank list enrties

 08-Sep-04	5432/1	allan	VBM:2004081803 Validation for range min and max values

 11-Jun-04	4691/1	allan	VBM:2004060202 Allow setFocus(XPath) to work with Elements

 14-May-04	4384/1	pcameron	VBM:2004050703 NewDevicePolicyWizard checks for duplicate policy names

 02-Apr-04	3717/1	doug	VBM:2004022404 Fixed ClassCastException problem

 01-Apr-04	3602/2	doug	VBM:2004030402 Added a StructurePolicyValueModifier

 17-Feb-04	2988/1	eduardo	VBM:2004020908 undo/redo reafctoring for multi-page editor

 05-Feb-04	2800/2	eduardo	VBM:2004012802 undo redo hooked in eclipse with demarcation. Designed just for single page editors

 03-Feb-04	2820/1	doug	VBM:2004013002 Used the eclipse 'externalize strings wizard' to identify language specific resources

 23-Jan-04	2682/3	doug	VBM:2003112506 Added StylePropertiesSection to eclipse gui

 23-Jan-04	2682/1	doug	VBM:2003112506 Added StylePropertiesSection to eclipse gui

 09-Jan-04	2506/3	philws	VBM:2004010810 Add constructor Javadoc

 09-Jan-04	2506/1	philws	VBM:2004010810 Fix XPath marker persistence

 07-Jan-04	2440/1	doug	VBM:2004010704 Fixed getParentStr() so that it handles absolute paths correctly

 06-Jan-04	2323/3	doug	VBM:2003120701 Added better validation error messages

 10-Dec-03	2057/12	doug	VBM:2003112803 fixed supermerge problems

 10-Dec-03	2057/10	doug	VBM:2003112803 fixed supermerge problems

 10-Dec-03	2057/7	doug	VBM:2003112803 Addressed several rework issues

 09-Dec-03	2057/5	doug	VBM:2003112803 Added SAX XSD Validation mechanism

 10-Dec-03	1968/2	richardc	VBM:2003111502 Second semi-tested draft for code release

 28-Nov-03	2041/3	byron	VBM:2003111502 Provide sophisticated, hierarchical ODOM ProxyElement - testcases

 28-Nov-03	2041/1	byron	VBM:2003111502 Provide sophisticated, hierarchical ODOM ProxyElement - testcases

 04-Dec-03	2105/3	philws	VBM:2003120301 Add more test cases and fix create method step XPath handling bug

 04-Dec-03	2105/1	philws	VBM:2003120301 Fix XPath's create method handling of multi-step creation and absolute paths

 27-Nov-03	2036/1	byron	VBM:2003111902 Element Selection implementation - added testcase and fixed bugs

 26-Nov-03	2018/8	byron	VBM:2003112503 Ensure recursion in constructor never happens

 26-Nov-03	2018/6	byron	VBM:2003112503 Fixed XPath equals method and added testcases

 25-Nov-03	2018/3	byron	VBM:2003112503 XPath augmentations and recursive delete apparent bug investigation - updated testcases

 25-Nov-03	2018/1	byron	VBM:2003112503 XPath augmentations and recursive delete apparent bug investigation

 24-Nov-03	1919/14	byron	VBM:2003111504 Provide ODOM XPath facilities - corrected javadoc

 24-Nov-03	1919/12	byron	VBM:2003111504 Provide ODOM XPath facilities - handled creation where xpaths select > 1 node.

 21-Nov-03	1919/10	byron	VBM:2003111504 Provide ODOM XPath facilities - fixed if statement

 21-Nov-03	1919/7	byron	VBM:2003111504 Provide ODOM XPath facilities - fixed javadoc and code formatting

 21-Nov-03	1919/5	byron	VBM:2003111504 Provide ODOM XPath facilities - update with issues resolved

 21-Nov-03	1919/3	byron	VBM:2003111504 Provide ODOM XPath facilities - update with issues resolved

 20-Nov-03	1919/1	byron	VBM:2003111504 Provide ODOM XPath facilities

 15-Nov-03	1825/1	byron	VBM:2003092601 Create generic policy property composite

 ===========================================================================
*/
